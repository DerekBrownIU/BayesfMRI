---
title: "BayesfMRI_simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BayesfMRI_simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(BayesfMRI)
```

Due to open access goals, brain tempate data were taken from FSL, rather than SPM8, as is used in [@mejia2020bayesian], and the binary mask image used is $45 \times 54$ (rather than $46 \times 55$). Using tools from the `neuRosim` package, the simulated data are recreated below:

```{r show template image activation profile and amplitude, message=F}
# Load the binary template image
data(binary_template)
# Create the activation profiles
library(neuRosim)
# Task 1
t1 <-
  specifydesign(
    onsets = seq(0, 200, by = 40),
    durations = 1,
    totaltime = 200,
    TR = 1,
    effectsize = 1.3,
    conv = "double-gamma",
    param = list(list(a1 = 6, a2 = 12, b1 = 0.9, b2 = 0.9, c = 0.15))
  )
t1 <- (t1 - mean(t1)) / max(t1)
# Task 2
t2 <-
  specifydesign(
    onsets = seq(20, 200, by = 40),
    durations = 1,
    totaltime = 200,
    TR = 1,
    effectsize = 1.3,
    conv = "double-gamma",
    param = list(list(a1 = 6, a2 = 12, b1 = 0.9, b2 = 0.9, c = 0.15))
  )
t2 <- (t2 - mean(t2)) / max(t2)
# Region 1
r1 <-
  specifyregion(
    dim = c(45, 54),
    coord = c(36, 28),
    radius = 2,
    form = "sphere",
    fading = 0.2
  )
# Region 2
r2 <-
  specifyregion(
    dim = c(45, 54),
    coord = c(12, 28), # Center of the activation
    radius = 3, # How big is the activation regions
    form = "sphere", # The activation are will be circular
    fading = 0.2 # How fast does the activation region fade (0 is no fade, 1 is fast fade)
  )
# Region 3
r3 <-
  specifyregion(
    dim = c(45, 54),
    coord = c(23, 16),
    radius = 4,
    form = "sphere",
    fading = 0.2
  )
# Create beta_1
beta_1 <- ifelse(binary_template == 0, NA, 0)
beta_1 <- beta_1 + r1 + r2
# Create beta_2
beta_2 <- ifelse(binary_template == 0, NA, 0)
beta_2 <- beta_2 + 0.8*(r2 + r3)
```

```{r sim data plot, message=F, warning=F}
# Recreate the plot of the activation profile, activation amplitude, and 
# the active regions
library(fields)
par(mar = c(4,2,1,1), mfrow = c(2,3))
plot(t1, type= 'l', xlab = "Time", ylab = "", yaxt = "n", xaxt = "n")
axis(1, at = seq(0,200,by  = 20))
axis(2,at = seq(-0.2,1.4, by = 0.2))
image.plot(beta_1, xaxt = "n", yaxt = "n")
image(beta_1 != 0, xaxt = "n", yaxt = "n", col = c("grey80", "red"))
par(mar=c(4,2,1,1))
plot(t2, type= 'l', xlab = "Time", ylab = "", yaxt = "n", xaxt = "n")
axis(1, at = seq(0,200,by  = 20))
axis(2,at = seq(-0.2,1.4, by = 0.2))
image.plot(beta_2, xaxt = "n", yaxt = "n", zlim = c(0,1))
image(beta_2 != 0, xaxt = "n", yaxt = "n", col = c("grey80", "red"))
```

```{r create data}
task_1_means <- beta_1 %o% c(t1)
task_2_means <- beta_2 %o% c(t2)
y_means <- task_1_means + task_2_means
y_t <- apply(y_means, 1:2, function(bv) {
  if(is.na(bv[1])) {
    return(rep(NA,length(bv)))
  } else {
    out <- 250 + bv + arima.sim(list(ar = 0.3), n = 200, sd = 2)
    return(out)
  }
})
y <- apply(y_t,1, identity)
y_exclude <- apply(y,1, function(yv) any(is.na(yv)))
y <- y[!y_exclude,]
y <- t(y)
```

```{r make the mesh}
library(INLA)
in_mask <- which(binary_template == 1, arr.ind = T)
in_mask <- in_mask[,2:1]
boundary <- inla.nonconvex.hull(in_mask, resolution = 100)
mesh <- inla.mesh.2d(loc = in_mask, boundary = boundary, max.edge = c(2,4))
# plot(mesh, main = "")
```

```{r}
# Make a session list (for INLA)
session <- list(
  BOLD = y,
  design = cbind(t1,t2)
)
# Make the data list (for INLA)
data <- list(
  single_session = session
)
# Make a conversion matrix to transform back to an image
convert_mat <- inla.spde.make.A(mesh = mesh, loc = in_mask)
```

```{r Classical GLM}
single_subject_classical <- classicalGLM(data = data, scale_BOLD = T, scale_design = T)
par(mfrow=c(1,2), mar = c(1,1,1,5))
# Get beta 1
classical_beta1 <- binary_template
classical_beta1[classical_beta1 == 1] <- single_subject_classical$single_session[,1]
classical_beta1[classical_beta1 == 0] <- NA
image.plot(classical_beta1, xaxt = "n", yaxt = "n", 
           zlim = c(min(single_subject_classical$single_session),
                    max(single_subject_classical$single_session)))
# Get beta 2
par(mar=c(1,1,1,5))
classical_beta2 <- binary_template
classical_beta2[classical_beta2 == 1] <- single_subject_classical$single_session[,2]
classical_beta2[classical_beta2 == 0] <- NA
image.plot(classical_beta2, xaxt = "n", yaxt = "n",
           zlim = c(min(single_subject_classical$single_session),
                    max(single_subject_classical$single_session)))
```


```{r Bayes GLM, warning=F, message=F}
# Run the Bayes
single_subject_result <- BayesGLM_surface(data = data, mesh = mesh, verbose = F)
```

```{r Find the activations}
active_betas_posterior <- 
  id_activations(model_obj = single_subject_result,method = "posterior",field_name = NULL,threshold = 0,alpha = 0.05,area.limit = NULL,type = NULL, n_sample = NULL)
```

