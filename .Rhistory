}
}
compute_vertex_areas()
compute_vertex_areas <- function(mesh)
{
if(missing(mesh))
{ print("This needs a valid mesh! Input a mesh now")}
if(class(mesh)==inla.mesh)
{
areas <- diag(inla.fmesher.smorg(mesh$loc,mesh$graph$tv, fem = 0, output = list("c0"))$c0)
return(areas)
}  else {
stop("Error in the class of mesh you input.It needs to be inla.mesh")
}
}
areas <- compute_vertex_areas(mesh)
class(mesh)
class(mesh)=="inla.mesh"
compute_vertex_areas <- function(mesh)
{
if(missing(mesh))
{ print("This needs a valid mesh! Input a mesh now")}
if(class(mesh)=="inla.mesh")
{
areas <- diag(inla.fmesher.smorg(mesh$loc,mesh$graph$tv, fem = 0, output = list("c0"))$c0)
return(areas)
}  else {
stop("Error in the class of mesh you input.It needs to be inla.mesh")
}
}
areas <- compute_vertex_areas(mesh)
head(areas)
length(areas)
#collect data and design matrices
y_all <- c()
X_all_list <- NULL
names(data)
session_names <- names(data)
session_names
n_sess <- length(session_names)
n_sess
s=1
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
BOLD_s <- BOLD_s[,mask==1]
dim(BOLD_s)
length(mask)
mask <- rep(1, V)
V
BOLD_s <- BOLD_s[,mask==1]
#scale data to represent % signal change
BOLD_s <- scale_timeseries(BOLD_s)
#scale data to represent % signal change
BOLD_s <- t(scale_timeseries(t(BOLD_s)))
dim(BOLD_s)
dim(data[[s]]$BOLD)
#scale data to represent % signal change
BOLD_s <- scale_timeseries(t(BOLD_s))
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
BOLD_s <- BOLD_s[,mask==1]
#scale data to represent % signal change
BOLD_s <- scale_timeseries(t(BOLD_s))
dim(BOLD_s)
#regress nuisance parameters from BOLD data and design matrix
design_s <- data[[s]]$design
y_reg=BOLD_s
X_reg=design_s
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, nx=nx, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
#organize the formula and data objects
formula <- make_formula(beta_names = names(betas), repl_names = names(repls), model_name = 'spde', hyper_initial = c(-2,2))
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
result <- estimate_model(formula=formula, data=model_data, A=model_data$X, prec_initial=1)
formula
nx
#construct betas and repls objects
nx <- 2 #fix this
replicates_list <- organize_replicates(n_sess=n_sess, nx=nx, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
#organize the formula and data objects
formula <- make_formula(beta_names = names(betas), repl_names = names(repls), model_name = 'spde', hyper_initial = c(-2,2))
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
formula
repls
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
result <- estimate_model(formula=formula, data=model_data, A=model_data$X, prec_initial=1)
names(result)
names(result$summary.random)
names(result$summary.random$bbeta1)
beta1 <- result$summary.random$bbeta1$mean
beta2 <- result$summary.random$bbeta2$mean
proj <- inla.mesh.projector(mesh, dims=c(nx,ny), xlim=c(1,nx), ylim=c(1,ny))
beta1.mat <- t(inla.mesh.project(proj, beta1))
beta2.mat <- t(inla.mesh.project(proj, beta2))
image(beta1.mat)
length(beta1.mat)
dim(beta1.mat)
nx=55
proj <- inla.mesh.projector(mesh, dims=c(nx,ny), xlim=c(1,nx), ylim=c(1,ny))
beta1.mat <- t(inla.mesh.project(proj, beta1))
beta2.mat <- t(inla.mesh.project(proj, beta2))
dim(beta1.mat)
image(beta1.mat)
## Read in Mask
mask <- as.matrix(read.table("../simulation/Mask"))
mask2 <- as.matrix(read.table("../simulation/Mask2"))
mask <- mask*mask2
image(beta1.mat*mask)
image(beta2.mat*mask)
scale=FALSE
## Read in Mask
mask <- as.matrix(read.table("../simulation/Mask"))
mask2 <- as.matrix(read.table("../simulation/Mask2"))
mask3D <- mask*mask2
repl1
repls
head(repls$repl1)
tail(repls$repl1)
length(repls$repl1)/2
betas
head(bbeta1)
head(betas$bbeta1)
tail(betas$bbeta1)
length(betas$bbeta1)
length(betas$bbeta1)/2
head(mesh$idx$loc)
mesh$idx$loc
length(mesh$idx$loc)
max(mesh$idx$loc)
names(X_reg)
length(y_reg)
ntime=5
nvox=10
ix <- 1:(ntime*nvox)
iy <- rep(1:nvox, each = ntime)
dim(X)
X=Z
dim(X)
X = X[1:5,]
X_k <- sparseMatrix(ix, iy, x=rep(X[,k], nvox))
k=1
X_k <- sparseMatrix(ix, iy, x=rep(X[,k], nvox))
X_k
X[,k]
formula
names(model_data)
formula
length(betas)
tinytex::install_tinytex()
formula
help(inla::f)
help(f)
help(INLA::f)
??INLA
??INLA::f
inla.doc('spde')
inla.doc('SPDE')
inla.doc('gaussian')
class(spde)
names(model_data)
a <- matrix(0, nrow=5, ncol=5)
a[1,2] = 1
a[2,4] = 1
a
a <- a %*% t(a)
a
a[1,2] = 1
a[2,4] = 1
a <- a + t(a)
a
a %*% a
knitr::opts_chunk$set(echo = TRUE)
library(fields) #image.plot
image.nan <- function(z, zlim, col, na.color='black', xlab='', axis.args=NULL, ...){
zlim_orig <- zlim
zstep <- (zlim[2] - zlim[1]) / length(col); # step in the color palette
#newz.below.outside <- zlim[1] - zstep # new z for values below zlim
#newz.above.outside <- zlim[2] + zstep # new z for values above zlim
newz.na <- zlim[2] + 2 * zstep # new z for NA
z[which(z<zlim[1])] <- zlim[1] # we affect newz.below.outside
z[which(z>zlim[2])] <- zlim[2] # we affect newz.above.outside
z[which(is.na(z>zlim[2]))] <- newz.na # same for newz.na
#zlim[1] <- zlim[1] - zstep # extend lower limit to include below value
zlim[2] <- zlim[2] + 2 * zstep # extend top limit to include the two new values above and na
cols <- c(col, na.color) # we construct the new color range by including: na.color and na.outside
nx <- ncol(z)
ny <- nrow(z)
obj.z <- list(x=1:ny, y=1:nx, z=z[ny:1,])
axis.args <- c(as.list(axis.args), cex = 1.5)
image.plot(obj.z, xlab=xlab, ylab='',  xlim=c(1,ny), ylim=c(1,nx), zlim=zlim, axis.args = axis.args, col=cols, xaxt="n", yaxt="n", ...)
rect(47,0,60,55, col="white", border="white", xpd=TRUE)
# Plot only the legend with original cutoffs
image.plot(obj.z, xlab=xlab, ylab='',  xlim=c(1,ny), ylim=c(1,nx), zlim=zlim_orig, axis.args = axis.args, col=col, legend.only=TRUE, ...)
}
getwd()
setwd('~/Dropbox/RESEARCH/BayesianGLM/SoftwarePaper/')
mask <- as.matrix(read.table("Mask"))
image.nan(mask)
image.nan(mask, zlim=c(0,1))
image.nan(mask, zlim=c(0,1), col=c('white','black'))
image.nan <- function(z, zlim, col, na.color='black', xlab='', axis.args=NULL, legend=TRUE, ...){
zlim_orig <- zlim
zstep <- (zlim[2] - zlim[1]) / length(col); # step in the color palette
#newz.below.outside <- zlim[1] - zstep # new z for values below zlim
#newz.above.outside <- zlim[2] + zstep # new z for values above zlim
newz.na <- zlim[2] + 2 * zstep # new z for NA
z[which(z<zlim[1])] <- zlim[1] # we affect newz.below.outside
z[which(z>zlim[2])] <- zlim[2] # we affect newz.above.outside
z[which(is.na(z>zlim[2]))] <- newz.na # same for newz.na
#zlim[1] <- zlim[1] - zstep # extend lower limit to include below value
zlim[2] <- zlim[2] + 2 * zstep # extend top limit to include the two new values above and na
cols <- c(col, na.color) # we construct the new color range by including: na.color and na.outside
nx <- ncol(z)
ny <- nrow(z)
obj.z <- list(x=1:ny, y=1:nx, z=z[ny:1,])
axis.args <- c(as.list(axis.args), cex = 1.5)
image.plot(obj.z, xlab=xlab, ylab='',  xlim=c(1,ny), ylim=c(1,nx), zlim=zlim, axis.args = axis.args, col=cols, xaxt="n", yaxt="n", ...)
rect(47,0,60,55, col="white", border="white", xpd=TRUE)
# Plot only the legend with original cutoffs
if(legend) image.plot(obj.z, xlab=xlab, ylab='',  xlim=c(1,ny), ylim=c(1,nx), zlim=zlim_orig, axis.args = axis.args, col=col, legend.only=TRUE, ...)
}
image.nan(mask, zlim=c(0,1), col=c('white','black'), legend=FALSE)
make_mesh <- function(vertices, faces, mask = NULL){
# Number of vertices
V <- nrow(vertices)
# Check the dimension of mask
if(is.null(mask)){
mask <- rep(1, V)
}else{
mask <- is.numeric(mask)
}
if(length(mask) != V | !is.vector(mask)){
stop("Mask should be a vector of length V")
}
# Check 0s and 1s
values <- sort(unique(mask))
if(values[1] != 0 | values[2] !=1 | length(values) != 2){
stop("Mask should be composed of only 0s and 1s")
}
# Check index of faces
if(min(faces) == 0){
faces <- faces + 1
}
# Apply mask to vertices
inmask <- which(mask)
vertices <- vertices[mask,]
# Identify and remove any triangles where at least one vertex is not included in the motor mask
faces <- faces[(faces[,1] %in% inmask) & (faces[,2] %in% inmask) & (faces[,3] %in% inmask),]
# Re-number faces
faces_new <- faces*0
for(ii in 1:nrow(faces_sh)){
faces_new[ii,1] <- which(inmask == faces[ii,1])
faces_new[ii,2] <- which(inmask == faces[ii,2])
faces_new[ii,3] <- which(inmask == faces[ii,3])
}
# Construct mesh
mesh <- inla.mesh.create(loc = as.matrix(vertices), tv = as.matrix(faces_new))
return(mesh)
}
par(mfrow=c(1,2))
mesh <- vol2mesh(mask)
image.nan(mask, zlim=c(0,1), col=c('white','black'), legend=FALSE)
plot(mesh)
par(mfrow=c(1,2))
image.nan(mask, zlim=c(0,1), col=c('white','black'), legend=FALSE)
plot(mesh)
image.nan(mask, zlim=c(0,1), col=c('white','black'), legend=FALSE)
plot(mesh)
BayesGLMfMRI <- function(data, vertices, faces, mesh, mask=NULL, scale=TRUE){
#check whether data is a list OR a session (for single-session analysis)
#check whether each element of data is a session (use is.session)
# V0 = full number of data locations
# V = masked number of data locations
# T = length of time series for each session (vector)
# K = number of unique tasks in all sessions
#need to check that sessions are consistent in terms of V, K?
#INLA:::inla.dynload.workaround() #avoid error on creating mesh
#maybe also allow the user to supply a mesh object
#check that only mesh OR vertices+faces supplied
has_mesh <- !missing(mesh)
has_verts_faces <- !missing(vertices) & !missing(faces)
has_howmany <- has_mesh + has_verts_faces
if(has_howmany != 1) error('Must supply EITHER mesh OR vertices and faces.')
}
BayesGLMfMRI(1, vertices=1, faces=1)
BayesGLMfMRI(1, vertices=1)
BayesGLMfMRI <- function(data, vertices, faces, mesh, mask=NULL, scale=TRUE){
#check whether data is a list OR a session (for single-session analysis)
#check whether each element of data is a session (use is.session)
# V0 = full number of data locations
# V = masked number of data locations
# T = length of time series for each session (vector)
# K = number of unique tasks in all sessions
#need to check that sessions are consistent in terms of V, K?
#INLA:::inla.dynload.workaround() #avoid error on creating mesh
#maybe also allow the user to supply a mesh object
#check that only mesh OR vertices+faces supplied
has_mesh <- !missing(mesh)
has_verts_faces <- !missing(vertices) & !missing(faces)
has_howmany <- has_mesh + has_verts_faces
if(has_howmany != 1) stop('Must supply EITHER mesh OR vertices and faces.')
}
BayesGLMfMRI(1, vertices=1)
BayesGLMfMRI(1, faces=1)
BayesGLMfMRI(1, mesh =1)
BayesGLMfMRI(1)
BayesGLMfMRI(1, vertices=1, faces=1)
mask <- as.matrix(read.table("../simulation/Mask"))
mask2 <- as.matrix(read.table("../simulation/Mask2"))
mask3D <- mask*mask2
## Construct Mesh to get Vertices and Faces
mesh <- vol2mesh(mask3D)
setwd()
getwd()
setwd('~/Dropbox/RESEARCH/BayesianGLMNonstat/simulation_mandy/')
mask <- as.matrix(read.table("../simulation/Mask"))
mask2 <- as.matrix(read.table("../simulation/Mask2"))
mask3D <- mask*mask2
## Construct Mesh to get Vertices and Faces
mesh <- vol2mesh(mask3D)
dat <- as.matrix(read.csv('FWHM20_NoisyData_1.csv', header=FALSE))
## Construct design matrix
z1 <- as.matrix(read.table('../simulation/Z1.txt'))
z2 <- as.matrix(read.table('../simulation/Z2.txt'))
Z <- cbind(z1, z2)
## Build session data
session <- list(BOLD = dat, design = Z)
setwd('~/Dropbox/RESEARCH/BayesianGLMNonstat/simulation_mandy/')
list.files()
## Read in timeseries data
dat <- as.matrix(read.csv('50datasets/FWHM20_NoisyData_1.csv', header=FALSE))
## Construct design matrix
z1 <- as.matrix(read.table('../simulation/Z1.txt'))
z2 <- as.matrix(read.table('../simulation/Z2.txt'))
Z <- cbind(z1, z2)
## Build session data
session <- list(BOLD = dat, design = Z)
data <- list(single_session = session)
class(data)
sapply(data, class)
is.session(data[[1]])
is.session <- function(sess){
# a valid "session" object is a list with the following fields
# - BOLD: T \times V matrix of BOLD responses, rows are time points, columns are voxels
# - design: T \times K matrix, where colnames holds the stimuli names
# - nuisance (optional): T \times J matrix, where colnames holds the nuisance regressor names
# these common dimensions must match across the objects
# - T: The number of time points
# - V: the number of voxels
# - K: the number of stimuli (regressors)
# - J: the number of nuisance regressors
#
# the checks that we need to run are
# 1. are there precisely three fields?
# 2. do the field names match
# 3. are each fields of the correct type
# 4. do the dimensions match
## check number of fields
num_fields <- length(sess)
if(num_fields == 3){
## check identities of fields
fields = c('BOLD','design','nuisance')
if(! all.equal(names(sess),fields)){stop(
paste0('You are missing the following fields',setdiff(names(sess),fields)))}
## check each field's type
if(! (is.numeric(sess$BOLD))){stop('I expected BOLD to be numeric, but it is not')}
if(! (is.matrix(sess$BOLD))){stop('I expected BOLD to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$nuisance))){stop('I expected nuisance to be a matrix, but it is not')}
if(! (is.matrix(sess$nuisance))){stop('I expected nuisance to be a matrix, but it is not')}
## check the dimensions of each field: T
if(nrows(BOLD) != nrows(design)){stop("BOLD and design don't have the same number of rows (time points)")}
if(nrows(BOLD) != nrows(nuisance)){stop("BOLD and nuisance don't have the same number of rows (time points)")}
if(nrows(design) != nrows(nuisance)){stop("design and nuisance don't have the same number of rows (time points)")}
} else if (num_fields==2){
## check identities of fields
fields = c('BOLD','design')
if(! all.equal(names(sess),fields)){stop(
paste0('You are missing the following fields',setdiff(names(sess),fields)))}
## check each field's type
if(! (is.numeric(sess$BOLD))){stop('I expected BOLD to be numeric, but it is not')}
if(! (is.matrix(sess$BOLD))){stop('I expected BOLD to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
## check the dimensions of each field: T
if(nrows(BOLD) != nrows(design)){stop("BOLD and design don't have the same number of rows (time points)")}
} else {
stop('I expected the session to have 2 or 3 fields, but it does not.')
}
return(TRUE)
}
is.session(data[[1]])
is.session <- function(sess){
# a valid "session" object is a list with the following fields
# - BOLD: T \times V matrix of BOLD responses, rows are time points, columns are voxels
# - design: T \times K matrix, where colnames holds the stimuli names
# - nuisance (optional): T \times J matrix, where colnames holds the nuisance regressor names
# these common dimensions must match across the objects
# - T: The number of time points
# - V: the number of voxels
# - K: the number of stimuli (regressors)
# - J: the number of nuisance regressors
#
# the checks that we need to run are
# 1. are there precisely three fields?
# 2. do the field names match
# 3. are each fields of the correct type
# 4. do the dimensions match
## check number of fields
num_fields <- length(sess)
if(num_fields == 3){
## check identities of fields
fields = c('BOLD','design','nuisance')
if(! all.equal(names(sess),fields)){stop(
paste0('You are missing the following fields',setdiff(names(sess),fields)))}
## check each field's type
if(! (is.numeric(sess$BOLD))){stop('I expected BOLD to be numeric, but it is not')}
if(! (is.matrix(sess$BOLD))){stop('I expected BOLD to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$nuisance))){stop('I expected nuisance to be a matrix, but it is not')}
if(! (is.matrix(sess$nuisance))){stop('I expected nuisance to be a matrix, but it is not')}
## check the dimensions of each field: T
if(nrow(BOLD) != nrow(design)){stop("BOLD and design don't have the same number of rows (time points)")}
if(nrow(BOLD) != nrow(nuisance)){stop("BOLD and nuisance don't have the same number of rows (time points)")}
if(nrow(design) != nrow(nuisance)){stop("design and nuisance don't have the same number of rows (time points)")}
} else if (num_fields==2){
## check identities of fields
fields = c('BOLD','design')
if(! all.equal(names(sess),fields)){stop(
paste0('You are missing the following fields',setdiff(names(sess),fields)))}
## check each field's type
if(! (is.numeric(sess$BOLD))){stop('I expected BOLD to be numeric, but it is not')}
if(! (is.matrix(sess$BOLD))){stop('I expected BOLD to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
## check the dimensions of each field: T
if(nrow(BOLD) != nrow(design)){stop("BOLD and design don't have the same number of rows (time points)")}
} else {
stop('I expected the session to have 2 or 3 fields, but it does not.')
}
return(TRUE)
}
is.session(data[[1]])
is.session <- function(sess){
# a valid "session" object is a list with the following fields
# - BOLD: T \times V matrix of BOLD responses, rows are time points, columns are voxels
# - design: T \times K matrix, where colnames holds the stimuli names
# - nuisance (optional): T \times J matrix, where colnames holds the nuisance regressor names
# these common dimensions must match across the objects
# - T: The number of time points
# - V: the number of voxels
# - K: the number of stimuli (regressors)
# - J: the number of nuisance regressors
#
# the checks that we need to run are
# 1. are there precisely three fields?
# 2. do the field names match
# 3. are each fields of the correct type
# 4. do the dimensions match
## check number of fields
num_fields <- length(sess)
if(num_fields == 3){
## check identities of fields
fields = c('BOLD','design','nuisance')
if(! all.equal(names(sess),fields)){stop(
paste0('You are missing the following fields',setdiff(names(sess),fields)))}
## check each field's type
if(! (is.numeric(sess$BOLD))){stop('I expected BOLD to be numeric, but it is not')}
if(! (is.matrix(sess$BOLD))){stop('I expected BOLD to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$nuisance))){stop('I expected nuisance to be a matrix, but it is not')}
if(! (is.matrix(sess$nuisance))){stop('I expected nuisance to be a matrix, but it is not')}
## check the dimensions of each field: T
if(nrow(sess$BOLD) != nrow(sess$design)){stop("BOLD and design don't have the same number of rows (time points)")}
if(nrow(sess$BOLD) != nrow(sess$nuisance)){stop("BOLD and nuisance don't have the same number of rows (time points)")}
if(nrow(sess$design) != nrow(sess$nuisance)){stop("design and nuisance don't have the same number of rows (time points)")}
} else if (num_fields==2){
## check identities of fields
fields = c('BOLD','design')
if(! all.equal(names(sess),fields)){stop(
paste0('You are missing the following fields',setdiff(names(sess),fields)))}
## check each field's type
if(! (is.numeric(sess$BOLD))){stop('I expected BOLD to be numeric, but it is not')}
if(! (is.matrix(sess$BOLD))){stop('I expected BOLD to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
if(! (is.matrix(sess$design))){stop('I expected design to be a matrix, but it is not')}
## check the dimensions of each field: T
if(nrow(sess$BOLD) != nrow(sess$design)){stop("BOLD and design don't have the same number of rows (time points)")}
} else {
stop('I expected the session to have 2 or 3 fields, but it does not.')
}
return(TRUE)
}
is.session(data[[1]])
devtools::load_all("~/Box/SOFTWARE/BayesGLMfMRI")
roxygenize()
