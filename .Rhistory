method = "exhaustive")
help("regsubsets")
dim(train.df)[2]
sum <- summary(search)
# show models
sum$which
# show metrics
data.frame(rsq = sum$rsq, adjr2 = sum$adjr2, cp=sum$cp)
#### Table 6.6
# use step() to run stepwise regression.
car.lm.step <- step(car.lm, direction = "backward")
summary(car.lm.step)  # Which variables were dropped?
## QUESTION FOR YOU:  Which variables were dropped?
car.lm.step.pred <- predict(car.lm.step, valid.df)
accuracy(car.lm.step.pred, valid.df$Price)
accuracy(car.lm.pred, valid.df$Price)
#### Table 6.7
# create model with no predictors
car.lm.null <- lm(Price~1, data = train.df)
# use step() to run forward regression.
car.lm.step <- step(car.lm.null, scope=list(lower=car.lm.null, upper=car.lm), direction = "forward")
summary(car.lm.step)  # Which variables were added?
car.lm.step.pred <- predict(car.lm.step, valid.df)
accuracy(car.lm.step.pred, valid.df$Price)
#### Table 6.8
# use step() to run stepwise regression.
car.lm.step <- step(car.lm, direction = "both")
summary(car.lm.step)  # Which variables were dropped/added?
car.lm.step.pred <- predict(car.lm.step, valid.df)
accuracy(car.lm.step.pred, valid.df$Price)
summary(search)
library(roxygen2)
roxygenixe()
roxygenize()
library(BayesfMRI)
roxygenize()
roxygenize()
library(BayesfMRI)
a = NULL
a
a$b
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
library(roxygen2)
roxygenize()
roxygenize()
roxygenize()
library(BayesfMRI)
roxygenize()
library(roxygen2md)
roxygenize()
library(BayesfMRI)
library(matrixStats) #colVars
library(spatstat) #blur
library(ggplot2)
library(ggthemes)
library(dplyr)
library(reshape2)
library(INLA)
library(pROC)
inla.setOption(pardiso.license = "~/pardiso.lic")
inla.pardiso.check()
library(templateICAr)
setwd('~/Desktop/Box/RESEARCH/SpatialTemplateICA/simulation')
#setwd('~/Box Sync/RESEARCH/SpatialTemplateICA/simulation')
#setwd('~/Box/RESEARCH/SpatialTemplateICA/simulation')
source('sim_funs.R')
####################################################################
####################################################################
### GENERATE SIMULATED DATA
####################################################################
####################################################################
###################################################################
# READ IN MEAN & VARIANCE (FROM MATLAB) AND GENERATE SUBJECT ICS
###################################################################
Nx <- 46
Ny <- 55
N <- Nx*Ny #number of voxels
mask <- matrix(1,nrow=Nx,ncol=Ny)
Q <- 3
load(file='template_orig.RData') #template_mean_orig, template_var_orig
FWHM <- 5
sig = FWHM/(2*sqrt(2*log(2)))
### tICA & stICA
t0_ii <- Sys.time()
source('~/Box/RESEARCH/SpatialTemplateICA/simulation/simulation.R', echo=TRUE)
debugSource('~/Box/RESEARCH/SpatialTemplateICA/simulation/simulation.R', echo=TRUE)
debugSource('~/Box/RESEARCH/SpatialTemplateICA/simulation/simulation.R', echo=TRUE)
debugSource('~/Box/SOFTWARE/templateICAr/R/templateICA.R', echo=TRUE)
subjIC_stICA_ii <-
templateICA(template_mean = template_mean,
template_var = template_var,
BOLD = Dat_ii,
scale=FALSE,
mesh=mymesh, #use spatial template ICA model
maxQ=Q, #no nuisance ICs
maxiter=100,
epsilon=0.001,
common_smoothness=TRUE,
verbose=TRUE,
kappa_init = 0.5,
excursions=TRUE,
dim_reduce_flag=TRUE)
theta0
dim(BOLD)
BOLD = Dat_ii
scale=FALSE
mesh=mymesh
maxQ=Q
maxiter=100
epsilon=0.001
common_smoothness=TRUE
verbose=TRUE
kappa_init = 0.5
xcursions=TRUE
excursions=TRUE
rm(xcursions)
dim_reduce_flag=TRUE
flag <- inla.pardiso.check()
if(grepl('FAILURE',flag)) stop('PARDISO IS NOT INSTALLED OR NOT WORKING. PARDISO is required for computational efficiency. See inla.pardiso().')
inla.setOption(smtp='pardiso')
ntime <- nrow(BOLD) #length of timeseries
nvox <- ncol(BOLD) #number of data locations
L <- nrow(template_mean) #number of ICs
#check that the number of data locations (nvox), time points (ntime) and ICs (L) makes sense
if(ntime > nvox) warning('More time points than voxels. Are you sure?')
if(L > nvox) stop('The arguments you supplied suggest that you want to estimate more ICs than you have data locations.  Please check the orientation and size of template_mean, template_var and BOLD.')
if(L > ntime) stop('The arguments you supplied suggest that you want to estimate more ICs than you have time points.  Please check the orientation and size of template_mean, template_var and BOLD.')
#check that all arguments have consistent number of data locations (nvox) and ICs (L)
if(ncol(template_mean) != nvox | ncol(template_var) != nvox) stop('template_mean, template_var and BOLD must have same number of data locations (columns), but they do not.')
if(nrow(template_var) != L) stop('template_mean and template_var must have the same number of ICs (rows), but they do not.')
if(is.null(mesh)){
message('No mesh supplied: Using standard template ICA model, which assumes spatial independence. If this is not what you want, stop and supply a valid mesh. See help(make_mesh).')
} else if(class(mesh) != 'templateICA_mesh'){
stop('mesh argument should be of class templateICA_mesh. See help(make_mesh).')
}
if(!is.null(maxQ)){
if(round(maxQ) != maxQ | maxQ <= 0) stop('maxQ must be NULL or a round positive number')
}
if(round(maxiter) != maxiter | maxiter <= 0) stop('maxiter must be a positive integer')
if(!is.null(kappa_init)){
if(length(kappa_init) != 1 | kappa_init <= 0) stop('kappa_init must be a positive scalar or NULL')
}
if(is.null(maxQ)) maxQ <- ntime
if(maxQ < L){
warning('maxQ must be at least L.  Setting maxQ=L.')
maxQ <- L
}
if(maxQ > ntime){
warning('maxQ must be no more than T.  Setting maxQ = T.')
maxQ <- ntime
}
if(class(scale) != 'logical' | length(scale) != 1) stop('scale must be a logical value')
if(class(common_smoothness) != 'logical' | length(common_smoothness) != 1) stop('common_smoothness must be a logical value')
if(maxQ > L){
#i. PERFORM DUAL REGRESSION TO GET INITIAL ESTIMATE OF TEMPLATE ICS
BOLD1 <- scale_BOLD(BOLD, scale=scale)
DR1 <- dual_reg(BOLD1, template_mean)
#ii. SUBTRACT THOSE ESTIMATES FROM THE ORIGINAL DATA --> BOLD2
fit <- DR1$A %*% DR1$S
BOLD2 <- BOLD1 - fit #data without template ICs
#iii. ESTIMATE THE NUMBER OF REMAINING ICS
#pesel function expects nxp data and will determine asymptotic framework
#here, we consider n=T (volumes) and p=V (vertices), and will use p-asymptotic framework
pesel_BOLD2 <- pesel(BOLD2, npc.max=100, method='homogenous')
Q2_hat <- pesel_BOLD2$nPCs #estimated number of nuisance ICs
if(verbose) cat(paste0('ESTIMATING AND REMOVING ',Q2_hat,' NUISANCE COMPONENTS'))
#iv. ESTIMATE THE NUISANCE ICS USING GIFT/INFOMAX
ICA_BOLD2 <- icaimax(t(BOLD2), nc=Q2_hat, center=TRUE)
#v. SUBTRACT THOSE ESTIMATES FROM THE ORIGINAL DATA --> BOLD3
fit <- ICA_BOLD2$M %*% t(ICA_BOLD2$S)
BOLD3 <- BOLD1 - fit #original data without nuisance ICs
} else {
# USE ORIGINAL DATA, SCALED, SINCE WE ARE ASSUMING NO NUISANCE COMPONENTS
BOLD3 <- scale_BOLD(BOLD, scale=scale) #center, and if scale=TRUE, scale
}
if(dim_reduce_flag) if(verbose) print('PERFORMING DIMENSION REDUCTION')
dat_list <- dim_reduce(BOLD3, L)
BOLD4 <- dat_list$data_reduced
H <- dat_list$H
Hinv <- dat_list$H_inv
C_diag <- dat_list$C_diag
dat_DR <- dual_reg(BOLD3, template_mean)
# Keep?
HA <- H %*% dat_DR$A #apply dimension reduction
#HA <- orthonorm(HA)  #orthogonalize
# sd_A <- sqrt(colVars(Hinv %*% HA)) #get scale of A (after reverse-prewhitening)
# HA <- HA %*% diag(1/sd_A) #standardize scale of A
theta0 <- list(A = HA)
#initialize residual variance
theta0$nu0_sq = dat_list$sigma_sq
if(verbose) print(paste0('nu0_sq = ',round(theta0$nu0_sq,1)))
#TEMPLATE ICA
if(!is.null(mesh)) print('INITIATING WITH STANDARD TEMPLATE ICA')
resultEM <- EM_templateICA.independent(template_mean, template_var, BOLD4, theta0, C_diag, maxiter=maxiter, epsilon=epsilon)
resultEM$A <- Hinv %*% resultEM$theta_MLE$A
tmp <- dual_reg(BOLD3, resultEM$subjICmean)
resultEM$A_reg <- tmp$A
resultEM_tICA <- resultEM
if(dim_reduce_flag == FALSE){
BOLD4 <- BOLD3
C_diag <- rep(1, ntime)
theta0$A <- dat_DR$A
}
theta0$kappa <- rep(kappa_init, L)
#project BOLD and templates to mesh locations
Amat <- mesh$A # n_orig x n_mesh matrix
nmesh <- ncol(Amat)
if(nrow(Amat) != nvox) stop('Mesh projection matrix (mesh$A) must have nvox rows (nvox is the number of data locations, the columns of BOLD, template_mean and template_var)')
BOLD=BOLD4
if(!all.equal(dim(template_var), dim(template_mean))) stop('The dimensions of template_mean and template_var must match.')
ntime <- nrow(BOLD) #length of timeseries
nvox <- ncol(BOLD) #number of data locations
if(ntime > nvox) warning('More time points than data locations. Are you sure?')
if(ncol(template_mean) != nvox) stop('Templates and BOLD must have the same number of data locations (columns).')
Q <- nrow(template_mean) #number of ICs
if(Q > nvox) stop('Cannot estimate more ICs than data locations.')
if(Q > ntime) stop('Cannot estimate more ICs than time points.')
if(class(mesh) != 'templateICA_mesh') stop('mesh argument should be of class templateICA_mesh. See help(make_mesh).')
iter = 1
theta = theta0
success = 1
V <- ncol(template_mean)
s0_vec = as.vector(t(template_mean))
D_vec <- as.vector(sqrt(t(template_var))) #template_var is QxV
D = Diagonal(V*Q, D_vec)
Dinv_s0 <- inla.qsolve(Q = D, B=matrix(s0_vec, ncol=1), method='solve')
if(verbose) cat('Refining starting value for kappa \n')
# Determine direction of change:
# Positive change --> search for kappa_max, set kappa_min to kappa1.
# Negative change --> search for kappa_min, set kappa_max to kappa1.
kappa_min <- kappa_max <- theta0$kappa[1]
theta1 <- UpdateTheta.spatial(template_mean, template_var, mesh, BOLD, theta0, C_diag, s0_vec, D, Dinv_s0, common_smoothness=TRUE, verbose=FALSE, dim_reduce_flag=dim_reduce_flag, update='kappa')
kappa_diff0 <- theta1$kappa[1] - theta0$kappa[1]
theta <- theta0
theta0$LL <- c(0,0)
theta0_vec <- unlist(theta0[1:3]) #everything but LL
names(theta0_vec)[1] <- 0 #store LL value in names of theta0_vec (required for squarem)
return_MAP=FALSE
update='all'
Q = nrow(template_mean)
V = ncol(BOLD)
ntime = nrow(BOLD)
spde = mesh$spde
#initialize new parameter values
theta_new = theta
#which parameters to update
update_A <- (update[1] == 'all' | update[1] =='A')
update_kappa <- (update[1] == 'all' | update[1] =='kappa')
if(update_A) theta_new$A <- NA
if(update_kappa) theta_new$kappa <- NA
if(!update_A & !update_kappa & !return_MAP) stop('Please indicate at least one parameter to update (e.g. update="A") or set return_MAP=TRUE to return MAP estimates of S based on current parameter values.')
if(verbose) cat('Computing Posterior Moments of S \n')
y_vec = as.vector(BOLD)
if(verbose) cat('...posterior precision \n') # less than 1 sec
#' @param R_inv Estimate of inverse spatial correlation matrix (sparse)
#' @param theta List of current parameter estimates
#' @param P Permutation matrix for regrouping by locations (instead of by ICs.)
#' @param C_diag Diagonals of residual covariance of the first level model. A vector of length Q.
#'
#' @return A list containing the posterior mean \eqn{\mu} (mu) and precision \eqn{\Omega} (Omega) of s=(s1,...,sQ), along with the supporting vector m, where \eqn{\mu = \Omega^{-1}m}.
#'
#' @import Matrix
#' @importFrom INLA inla.qsolve
#'
compute_mu_s <- function(y_vec, D, Dinv_s0, R_inv, theta, P, C_diag){
ntime <- length(C_diag)
Q <- ncol(theta$A)
V <- nrow(P)/Q
A <- theta$A
nu0_sq <- theta$nu0_sq
#set up B, C, and products thereof
ones = Diagonal(V)
B = kronecker(ones, A)
nu0C_inv = kronecker(ones, diag(1/(C_diag*nu0_sq)))
Pt_Bt_nu0C_inv = t(P) %*% t(B) %*% nu0C_inv
#compute m (using current parameter estimates in theta)
m1_vec <- D %*% Pt_Bt_nu0C_inv %*% y_vec
m2_vec <- R_inv %*% Dinv_s0
m_vec <- m1_vec + m2_vec
# Compute Omega (using current parameter estimates in theta)
Omega <- R_inv + D %*% Pt_Bt_nu0C_inv %*% B %*% P %*% D
# Compute mu_s|y by solving for x in the system of equations Omega*x = m
Omega_inv_m <- inla.qsolve(Q = Omega, B=m_vec, method='solve') # <-- slowest part (up to 1 hour for Q=16, V=5500), but with inla.setOption(smtp='pardiso') goes down to 20 seconds!
mu_s <- D %*% Omega_inv_m
return(list(mu=mu_s, m=m_vec, Omega=Omega, Omega_inv_m=Omega_inv_m))
}
#'
#' @param mesh Object of class "templateICA_mesh" containing the triangular mesh (see `help(make_mesh)`)
#' @param kappa Current estimates of SPDE parameter kappa for each latent field
#' @param C1 Constant, equal to 1/(4*pi) for a 2-dimensional field with alpha=2
#'
#' @return A list containing R inverse and SPDE matrices
#'
#' @import Matrix
#' @importFrom stats var
#'
compute_R_inv <- function(mesh, kappa, C1=1/(4*pi)){
Q <- length(kappa)
#SPDE matrices, needed to construct R_q_inv
spde = mesh$spde
Fmat = spde$param.inla$M0
Gmat = 1/2*(spde$param.inla$M1 + Matrix::t(spde$param.inla$M1))
GFinvG = spde$param.inla$M2 #this equals G %*% solve(F) %*% G
if(var(kappa)==0) onekappa <- TRUE
if(length(kappa)==1) onekappa <- TRUE
if(onekappa) kappa <- kappa[1]
#get inmesh and notinmesh indices
Amat = mesh$A #n_loc x n_mesh
N = ncol(mesh$A) #number of mesh locations
inmesh = which(colSums(Amat) > 0)
notinmesh = setdiff(1:N, inmesh)
#set up R^{-1} (QVxQV) as a sparse block diagonal matrix
if(onekappa){ #just compute Rinv once
Qmat = C1*(kappa^2 * Fmat + 2 * Gmat + kappa^(-2) * GFinvG)
Q11 = Qmat[inmesh,inmesh] # = Amat %*% Qmat %*% t(Amat)
Q12 = Qmat[inmesh, notinmesh]
Q21 = Qmat[notinmesh, inmesh]
Q22 = Qmat[notinmesh,notinmesh]
Q22_inv <- solve(Q22)
R_q_inv = Q11 - (Q12 %*% Q22_inv %*% Q21)
R_inv_list <- rep(list(R_q_inv), Q)
} else { # compute Rinv block-wise
R_inv_list = vector('list', Q)
for(q in 1:Q){
kappa_q = kappa[q]
R_q_inv = C1 * (kappa_q^2 * Fmat + 2 * Gmat + kappa_q^(-2) * GFinvG)
R_inv_list[[q]] = R_q_inv
}
}
R_inv <- bdiag(R_inv_list)
return(list(R_inv=R_inv, Fmat=Fmat, Gmat=Gmat, GFinvG=GFinvG))
}
#'
#' @param Q The number of template ICs
#' @param V The number of spatial locations
#'
#' @return P Permutation matrix size QVxQV
#'
#' @details If s=(s1,...,sQ) is grouped by ICs 1,...Q, then Ps=(s(1),...,s(V)) is grouped by locations 1,...,V
#'
#' @importFrom Matrix sparseMatrix
#'
make_Pmat <- function(Q, V){
cols = 1:(Q*V)
rows_P1 = seq(1, (Q-1)*V+1, by=V)
offset = rep(0:(V-1), each=Q)
rows = rep(rows_P1, V) + offset
P = t(sparseMatrix(i = rows, j = cols))
}
#'
#' @description Code for function provided in examples of bdiag function from Matrix package
#'
#' @param lmat List of matrices
#'
#' @import Matrix
#' @importFrom methods new
#'
#' @return A sparse matrix obtained by combining the arguments into a block diagonal matrix
#'
bdiag_m <- function(lmat) {
## Copyright (C) 2016 Martin Maechler, ETH Zurich
if(!length(lmat)) return(new("dgCMatrix"))
stopifnot(is.list(lmat), is.matrix(lmat[[1]]),
(k <- (d <- dim(lmat[[1]]))[1]) == d[2], # k x k
all(vapply(lmat, dim, integer(2)) == k)) # all of them
N <- length(lmat)
if(N * k > .Machine$integer.max)
stop("resulting matrix too large; would be  M x M, with M=", N*k)
M <- as.integer(N * k)
## result: an   M x M  matrix
new("dgCMatrix", Dim = c(M,M),
## 'i :' maybe there's a faster way (w/o matrix indexing), but elegant?
i = as.vector(matrix(0L:(M-1L), nrow=k)[, rep(seq_len(N), each=k)]),
p = k * 0L:M,
x = as.double(unlist(lmat, recursive=FALSE, use.names=FALSE)))
}
#Compute SPDE matrices (F, G, GFinvG) and Sigma_inv (QVxQV), a sparse block diagonal matrix
stuff <- compute_R_inv(mesh, kappa=theta$kappa, C1=1/(4*pi))
R_inv <- stuff$R_inv
Fmat <- stuff$Fmat
Gmat <- stuff$Gmat
GFinvG <- stuff$GFinvG
#set up P as a sparse matrix (see OneNote for illustration of this)
P <- make_Pmat(Q, V)
#1. Compute mu_s
if(verbose) cat('...posterior mean \n') #20 seconds with pardiso! (1 hour without)
stuff <- compute_mu_s(y_vec, D, Dinv_s0, R_inv, theta, P, C_diag)
mu_s <- stuff$mu
m_vec <- stuff$m
Omega <- stuff$Omega
Omega_inv_m <- stuff$Omega_inv_m
save('~/tmp.Rdata')
save(file='~/tmp.Rdata')
save.image(file='~/tmp.Rdata')
Omega_inv <- inla.qinv(Omega)
vars <- diag(D %*% Omega_inv %*% D)
length(vars)
length(vars)/3
summary()
summary(vars[1:N])
my.image.scale(vars[1:N], mask=mask, min=0, max=0.1, cols=c('black','red','yellow','white'))
my.image.scale(resultEM_tICA$subjICvar[1:N], mask=mask, min=0, max=0.1, cols=c('black','red','yellow','white'), title='tICA')
my.image.scale(resultEM_tICA$subjICvar[1,], mask=mask, min=0, max=0.1, cols=c('black','red','yellow','white'), title='tICA')
dim(template_var)
theta_MLE = theta0
mu_Omega_s = UpdateTheta.spatial(template_mean, template_var, mesh, BOLD, theta_MLE, C_diag, s0_vec, D, Dinv_s0, common_smoothness=common_smoothness, verbose=verbose, return_MAP=TRUE)
result <- list(subjICmean=mu_Omega_s$mu_s, subjICcov=subjICcov, Omega = mu_Omega_s$Omega_s, theta_MLE=theta_MLE, theta_path=theta_path, numiter=numiter, squarem = result_squarem)
subjICcov=(D %*% inla.qinv(mu_Omega_s$Omega_s) %*% D)
result <- list(subjICmean=mu_Omega_s$mu_s, subjICcov=subjICcov, Omega = mu_Omega_s$Omega_s, theta_MLE=theta_MLE, theta_path=theta_path, numiter=numiter, squarem = result_squarem)
numiter=1
result <- list(subjICmean=mu_Omega_s$mu_s, subjICcov=subjICcov, Omega = mu_Omega_s$Omega_s, theta_MLE=theta_MLE, theta_path=theta_path, numiter=numiter, squarem = result_squarem)
result_squarem=NULL
result <- list(subjICmean=mu_Omega_s$mu_s, subjICcov=subjICcov, Omega = mu_Omega_s$Omega_s, theta_MLE=theta_MLE, theta_path=theta_path, numiter=numiter, squarem = result_squarem)
resultEM=result
#project estimates back to data locations
resultEM$subjICmean_mat <- t(matrix(resultEM$subjICmean, ncol=L))
if(verbose) cat('Determining areas of activation in each IC \n')
active <- jointPPM <- marginalPPM <- matrix(NA, nrow=Q, ncol=nvox)
q=1
if(verbose) cat(paste0('.. ',q,' of ',L,' \n'))
inds_q <- (1:nvox) + (q-1)*nvox
#we scale mu by D^(-1) to use Omega for precision, only works if u=0
Dinv_mu_s <- (resultEM$subjICmean/as.vector(t(sqrt(template_var))))
print(system.time(res_q <- excursions(alpha = 0.1, mu = Dinv_mu_s, Q = resultEM$Omega, type = ">", u = 0, ind = inds_q)))
library(excursions)
print(system.time(res_q <- excursions(alpha = 0.1, mu = Dinv_mu_s, Q = resultEM$Omega, type = ">", u = 0, ind = inds_q)))
N
summary(res_q$rho[inds_q])
my.image.scale(res_q$rho[inds_q], mask=mask, min=0, max=1, col=c('black','red','yellow','white'), title='marginal PPM')
roc(response = 1*(subjICs_fi > 0), predictor = res_q$rho[inds_q], plot=TRUE)
dim(subjICs_fi)
roc(response = 1*(subjICs_fi[,1] > 0), predictor = res_q$rho[inds_q], plot=TRUE)
roc(response = 1*(subjICs_fi[,1] > 0), predictor = res_q$rho[inds_q])
my.image.scale(subjICs_fi[,1] > 0, mask=mask, min=0, max=1, col=c('black','red','yellow','white'), title='marginal PPM')
my.image.scale((subjICs_fi[,1] > 0)*1, mask=mask, min=0, max=1, col=c('black','red','yellow','white'), title='true active map')
plot(1:3)
par(mfroc=c(1,1))
par(mfrow=c(1,1))
par(mar=c(2,2,2,2))
my.image.scale((subjICs_fi[,1] > 0)*1, mask=mask, min=0, max=1, col=c('black','red','yellow','white'), title='true active map')
my.image.scale(res_q$rho[inds_q], mask=mask, min=0.9, max=1, col=c('black','red','yellow','white'), title='marginal PPM')
my.image.scale(res_q$rho[inds_q], mask=mask, min=0.99, max=1, col=c('black','red','yellow','white'), title='marginal PPM')
act_troo <- (subjICs_fi[,1] > 0)
marPPM <- res_q$rho[inds_q]
summary(marPPM[act_troo])
summary(marPPM[!act_troo])
roc(response = 1*(subjICs_fi[,1] > 0), predictor = res_q$rho[inds_q], plot=TRUE)
par(mfrow=c(1,1))
par(mar=c(2,2,2,2))
roc(response = 1*(subjICs_fi[,1] > 0), predictor = res_q$rho[inds_q], plot=TRUE)
a <- matrix(rnorm(9), nrow=3)
library(Matrix)
rankMatrix(a)
rankMatrix(as.data.frame(a))
a <- data.frame(V1=rnorm(9), V2=rnorm(9))
rankMatrix(a)
a
as.matrix(a)
load("/Users/afmejia/Downloads/NuisanceMatrix.RData")
head(nuismat)
t(nuismat) %*% nuismat
image(t(nuismat) %*% nuismat)
image(t(nuismat) %*% nuismat)
tail(nuismat)
library(roxygen2)
library(roxygen2md)
roxygenize()
install.packages('neuRosim')
install.packages('neuRosim')
roxygenize()
library(roxygen2md)
library(roxygen2)
install.packages('roxygen2')
install.packages('roxygen2md')
library(roxygen2md)
roxygenize()
library(roxygen2)
roxygenize()
install.packages('gifti')
install.packages('geometry')
install.packages('pesel')
install.packages('matrixStats')
roxygenize()
install.packages('rdist')
install.packages('rgl')
install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
roxygenize()
install.packages('ica','SQUAREM')
roxygenize()
install.packages('SQUAREM')
roxygenize()
library(devtools)
install_github('ciftiTools')
install_github('mandymejia/ciftiTools')
roxygenize()
install.packages('neuRosim')
roxygenize()
roxygenize()
roxygenize()
roxygenize()
#install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
#ON CARBONATE NEED AN ALTERNATIVE LINUX BUILD FOR CentOS Linux-7
#FOLLOW INSTRUCTIONS HERE: http://www.r-inla.org/events/alternativelinuxbuilds
#BASICALLY NEED TO DOWNLOAD AN ALTERNATIVE 64bit DIRECTORY AND REPLACE EXISTING ONE
library(INLA)
inla.setOption(pardiso.license = "~/pardiso.lic")
inla.pardiso.check()
