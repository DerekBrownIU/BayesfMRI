## Build session data
session <- list(BOLD = dat, design = Z)
is.session(session)
## Read in timeseries data
dat2 <- as.matrix(read.csv('example/FWHM20_NoisyData_2.csv', header=FALSE))
## Build session data
session2 <- list(BOLD = dat2, design = Z)
is.session(session2)
data <- list(sess1 = session, sess2 = session2)
result <- BayesfMRI::BayesGLM(data, mesh=mesh)
install.packages('alr4')
library(alr4)
View(BGSgirls)
min(5, NULL)
x <- rnorm(10000)
install.packages('entropy')
entropy(x)
library(entropy)
entropy(x)
log(sqrt(2*pi*exp(1)))
install.packages('DescTools')
library(DescTools)
h <- hist(x)
h <- hist(x, breaks=100)
names(h)
entropy(h$counts)
h <- hist(x, breaks=1000)
entropy(h$counts)
h <- hist(x, breaks=50)
entropy(h$counts)
library(devtools)
install_github('mandymejia/BayesfMRI')
library(BayesfMRI)
library(roxygen2)
library(roxygen2md)
roxygenize()
library(BayesfMRI)
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
library(BayesfMRI)
library(devtools)
install_github('mandymejia/BayesfMRI')
library(BayesfMRI)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(knitr)
# library(rgl)
knit_hooks$set(webgl = hook_webgl)
#library(devtools)
#install_github('mandymejia/BayesfMRI')
library(BayesfMRI)
library(INLA)
## Read in the mask
load('example/Mask.Rdata') #mask3D
## Create a mesh using inla.mesh.2d
xy.in <- which(mask3D==1, arr.ind=TRUE)[,2:1]
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
## Create a matrix to translate between original and mesh locations
Amat <- inla.spde.make.A(mesh, loc=xy.in)
## Plot mask and mesh
image(t(mask3D), xaxt='n', yaxt='n', col=c('white','black'))
plot(mesh, main='')
dat <- as.matrix(read.csv('example/FWHM20_NoisyData_1.csv', header=FALSE))
## Construct design matrix
z1 <- as.matrix(read.table('example/Z1.txt'))
z2 <- as.matrix(read.table('example/Z2.txt'))
Z <- cbind(z1, z2)
## Plot task regressors over time
plot(z1, type='l', ylab='', main='HRF Task Regressors')
lines(z2, col='red')
## Build session data
session <- list(BOLD = dat, design = Z)
is.session(session)
data <- list(single_session = session)
result <- BayesfMRI::BayesGLM(data, mesh=mesh)
result1 <- result
dat2 <- as.matrix(read.csv('example/FWHM20_NoisyData_2.csv', header=FALSE))
## Build session data
session2 <- list(BOLD = dat2, design = Z)
data2 <- list(single_session = session2)
result2 <- BayesfMRI::BayesGLM(data2, mesh=mesh, return_INLA_result=FALSE)
result.lst <- list(sub1 = result1, sub2 = result2)
Amat <- inla.spde.make.A(mesh, loc=xy.in)
thresholds <- c(0, 0.5)
result.grp <- BayesfMRI::BayesGLM_group(result.lst, A = Amat, thresholds = thresholds, alpha = 0.05)
list(a=1:3, b=3:4)
# Read beta estimates
beta.tot <- result.grp$beta_estimates
visualize_vec2img(
values = Amat %*% beta.tot,
field_names = c('beta1', 'beta2'),
pal = c('purple','blue','turquoise','yellow','orange','red','darkred'),
xy.inds = xy.in[,2:1],
zlim = c(-0.3, 1.3)
)
library(ggplot2)
visualize_vec2img <- function(values, field_names, xy.inds, pal=NULL, gradient2=FALSE, zlim=NULL){
#values is a matrix where each column is a vectorized, masked image
#names are the names of the fields corresponding to each column of values
#xy.in are the col- and row-indices in the original image corresponding to the rows of values
#pal is the color palette to use for the image
#zlim is a vector of the lower and upper limits for the intensity values
values_df <- data.frame(value = as.vector(values),
field = rep(field_names, each=length(values)/length(field_names)),
row = xy.inds[,1],
col = xy.inds[,2])
if(!is.null(zlim)){
print(paste0(sum(values_df$value > zlim[2]), ' pixels above upper z-limit')) #very few values
print(paste0(sum(values_df$value < zlim[1]), ' pixels above upper z-limit')) #very few values
values_df$value[values_df$value > zlim[2]] <- zlim[2]
values_df$value[values_df$value < zlim[1]] <- zlim[1]
}
p <- ggplot(values_df) +
geom_tile(aes(x = 41-row, y = col, color = value, fill = value)) +
facet_grid(. ~ field) + xlab('') + ylab('') +
theme_bw() + theme(panel.grid=element_blank())
if(!is.null(pal)){
p <- p + scale_color_gradientn("", colors=pal, na.value = "black", limits=zlim) +
scale_fill_gradientn("", colors=pal, na.value = "black", limits=zlim)
} else if (gradient2==TRUE) {
p <- p + scale_color_gradient2("", na.value = "black", limits=zlim) +
scale_fill_gradient2("", na.value = "black", limits=zlim)
} else {
p <- p + scale_color_gradient("", na.value = "black", limits=zlim) +
scale_fill_gradient("", na.value = "black", limits=zlim)
}
return(p)
}
# Visualize beta estimates
visualize_vec2img(
values = Amat %*% beta.tot,
field_names = c('beta1', 'beta2'),
pal = c('purple','blue','turquoise','yellow','orange','red','darkred'),
xy.inds = xy.in[,2:1],
zlim = c(-0.3, 1.3)
)
# Read activation regions
active <- result.grp$active
for(u in 1:length(thresholds)){
values = Amat %*% active[,,u]
values_all <- matrix(NA, nrow=length(mask3D), ncol=ncol(values))
values_all[as.vector(mask3D) == 1,] <- as.matrix(values)
visualize_vec2img(
values = values_all,
field_names = c('beta1', 'beta2'),
gradient2=TRUE,
xy.in = which(mask3D >= 0, arr.ind=TRUE)
)
}
library(alr4)
help("fuel2001")
scatterplotMatrix(fuel2001)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth()
library(ggplot2)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=Miles, y=MPC)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=MPC, y=FuelC)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth()
lm1 <- lm(FuelC ~ Miles, data=fuel2001)
fuel2001$pred_lm1 <- predict(lm1, fuel2001)
fuel2001$resid_lm1 <- fuel2001$FuelC - fuel2001$pred_lm1
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth() + theme_few()
library(ggthemes)
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_vline(yintercept=0, col='red')
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_hline(yintercept=0, col='red')
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
plot(lm1)
par(mfrow=c(2,2))
plot(lm1, which = 1)
plot(lm1, which = 2)
plot(lm1, which = 3)
plot(lm1, which = 4)
plot(lm1)
plot(lm1)
par(mfrow=c(1,1))
plot(lm1)
hist(fuel2001$Miles)
hist(fuel2001$FuelC)
hist(fuel2001$Miles, breaks=30)
hist(fuel2001$FuelC, breaks=30)
hist(fuel2001$FuelC, breaks=30, fill='turquoise')
hist(fuel2001$Miles, breaks=30, col='turquoise')
hist(fuel2001$FuelC, breaks=30, col='turquoise')
hist(fuel2001$Miles, breaks=25, col='turquoise')
hist(fuel2001$FuelC, breaks=25, col='turquoise')
lm2 <- lm(log(FuelC) ~ Miles, data=fuel2001)
fuel2001$pred_lm1 <- predict(lm1, fuel2001)
fuel2001$resid_lm1 <- log(fuel2001$FuelC) - fuel2001$pred_lm1
lm2 <- lm(log(FuelC) ~ Miles, data=fuel2001)
fuel2001$pred_lm2 <- predict(lm2, fuel2001)
fuel2001$resid_lm2 <- log(fuel2001$FuelC) - fuel2001$pred_lm2
head(fuel2001)
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1^2)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
ggplot(fuel2001, aes(x=pred_lm2, y=resid_lm2)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
ggplot(fuel2001, aes(x=pred_lm2, y=resid_lm2^2)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
library(alr4)
help(fuel2001)
scatterplotMatrix(fuel2001)
library(ggplot2)
library(ggthemes)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth() + theme_few()
hist(fuel2001$Miles, breaks=25, col='turquoise')
hist((fuel2001$FuelC), breaks=25, col='turquoise')
hist(fuel2001$FuelC, breaks=25, col='turquoise')
lm1 <- lm(FuelC ~ Miles, data=fuel2001)
fuel2001$pred_lm1 <- predict(lm1, fuel2001)
fuel2001$resid_lm1 <- fuel2001$FuelC - fuel2001$pred_lm1
par(mfrow=c(2,2))
plot(lm1, which = 1)
plot(lm1, which = 2)
plot(lm1, which = 3)
plot(lm1, which = 5)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth() + theme_few()
hist(fuel2001$FuelC, breaks=25, col='turquoise')
ggplot(fuel2001, aes(x=Miles, y=log(FuelC))) + geom_point() + geom_smooth() + theme_few()
lm2 <- lm(log(FuelC) ~ Miles, data=fuel2001)
fuel2001$pred_lm2 <- predict(lm2, fuel2001)
fuel2001$resid_lm2 <- log(fuel2001$FuelC) - fuel2001$pred_lm2
par(mfrow=c(2,2))
plot(lm2, which = 1)
plot(lm2, which = 2)
plot(lm2, which = 3)
plot(lm2, which = 5)
hist(fuel2001$Pop, breaks=30, col='turquoise')
fuel2001$large_state <- (fuel2001$Pop > 1.0e7)
table(fuel2001$large_state)
ggplot(fuel2001, aes(x=Miles, y=log(FuelC), group=large_state, color=large_state)) + geom_point() + geom_smooth() + theme_few()
lm3int <- lm(log(FuelC) ~ Miles*large_state, data=fuel2001)
lm3int <- lm(log(FuelC) ~ Miles + large_state + Miles:large_state, data=fuel2001)
lm3 <- lm(log(FuelC) ~ Miles + large_state, data=fuel2001)
Miles_pred <- seq(0, 3e5, 1)
large_state_pred <- c(TRUE, FALSE)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred)
newdata$fitted_lm3int <- predict(lm3int, newdata=newdata)
newdata$fitted_lm3 <- predict(lm3, newdata=newdata)
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line()
Miles_pred <- seq(0, 3e5, 1000)
large_state_pred <- c(TRUE, FALSE)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred)
newdata$fitted_lm3int <- predict(lm3int, newdata=newdata)
newdata$fitted_lm3 <- predict(lm3, newdata=newdata)
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line()
ggplot(fuel2001, aes(x=Miles, y=log(FuelC), group=large_state, color=large_state)) + geom_point() + geom_smooth() + theme_few() + theme(legend.position='bottom')
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
hist(fuel2001$Income)
lm4 <- lm(log(FuelC) ~ Miles + large_state + Income, data=fuel2001)
Miles_pred <- seq(0, 3e5, 1000)
large_state_pred <- c(TRUE, FALSE)
Income_pred <- seq(20000,45000,100)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred, Income=Income_pred)
newdata$fitted_lm4 <- predict(lm4, newdata=newdata)
newdata_Incomefixed <- filter(newdata, Income==30000)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred, Income=Income_pred)
newdata$fitted_lm4 <- predict(lm4, newdata=newdata)
ggplot(newdata, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
newdata_Incomefixed <- filter(newdata, Income==30000)
ggplot(newdata_Incomefixed, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
library(dplyr)
newdata_Incomefixed <- dplyr::filter(newdata, Income==30000)
ggplot(newdata_Incomefixed, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
p1 <- ggplot(newdata, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
p2 <- ggplot(newdata_Incomefixed, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
library(gridExtra)
grid.arrange(p1, p2)
grid.arrange(p1, p2, nrow=1)
install.packages('ggseg')
install.packages('ggseg3d')
source("https://neuroconductor.org/neurocLite.R")
neuro_install('ggseg')
neuro_install('ggseg3d')
library(ggseg)
help("ggseg")
library(devtools)
install_github('mandymejia/ciftiTools')
# devtools::install_github("mandymejia/BayesfMRI")
library(BayesfMRI)
main_dir <- '~/Box/RESEARCH/BayesGLM_Validation/data/HCP'
#main_dir <- '/N/project/BayesGLM_Validation/HCP/'
wd_ts <- 'data_processed/subcortical/tseries/sess1'
wd_z <- 'data_processed/designmat'
wd_spde <- 'data_processed/subcortical/spde_subcortical'
wd_outfile <- 'results_subcortical'
setwd(main_dir)
# Working directories
main_dir <- '~/Box Sync/RESEARCH/BayesGLM_Validation/data/HCP'
setwd(main_dir)
wb_cmd <- '/Applications/workbench/bin_macosx64/wb_command'
# Select id (do this in bash script once moved to cluster)
id <- '103818'
#location of subject meshes
fname_cifti <- '103818.sess1.tfMRI_MOTOR_RL.10k.dtseries.nii'
fname_gifti_left <- 'data_processed/subject_meshes/103818.L.midthickness.10k.surf.gii'
fname_gifti_right <- 'data_processed/subject_meshes/103818.R.midthickness.10k.surf.gii'
dir <- wd_ts
list.files(dir)
#main_dir <- '/N/project/BayesGLM_Validation/HCP/'
#wd_ts <- 'data_processed/subcortical/tseries/sess1'
wd_ts <- 'data_processed/timeseries'
dir <- wd_ts
#design matrix
fname_Z <- paste0(id,'.sess1.tfMRI_MOTOR_RL.csv')
Z <- read.csv(file.path(wd_z, fname_Z), header=FALSE) #284x6
Z <- as.matrix(Z)
dim(Z)
plot(1:284, Z[,1], type='l')
brainstructures=c('left','right')
design=Z
GLM_method='classical'
session_names=NULL
if(is.null(dir)) dir <- getwd()
all_files <- list.files(dir)
if(min(fname_cifti %in% all_files)==0) stop('fname_cifti (or at least one element thereof) does not exist in specified or current working directory')
do_left <- ('left' %in% brainstructures)
do_right <- ('right' %in% brainstructures)
do_sub <- ('sub' %in% brainstructures)
if(do_left & is.null(fname_gifti_left)) stop('fname_gifti_left must be provided if brainstructures includes "left"')
if(do_right & is.null(fname_gifti_right)) stop('fname_gifti_left must be provided if brainstructures includes "left"')
if((is.null(design) + is.null(onsets)) != 1) stop('design OR onsets must be provided, but not both')
onsets=NULL
if((is.null(design) + is.null(onsets)) != 1) stop('design OR onsets must be provided, but not both')
n_sess <- length(fname_cifti)
if(n_sess==1){
if(is.null(session_names)) session_names <- 'single_session'
fname_cifti <- list(fname_cifti)
if(!is.null(design)) design <- list(design)
#if(!is.null(onsets)) onsets <- list(onsets)
if(!is.null(nuisance)) nuisance <- list(nuisance)
} else {
if(is.null(session_names)) session_names <- paste0('session', 1:n_sess)
if(!is.null(design)){ if(length(design) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), design must be a list of length equal to the number of sessions (or NULL, if onsets provided).') }
#if(!is.null(onsets)){ if(length(onsets) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), onsets must be a list of length equal to the number of sessions (or NULL, if design provided).') }
if(!is.null(nuisance)){ if(length(nuisance) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), nuisance must be a list of length equal to the number of sessions (or NULL).') }
}
if(length(session_names) != n_sess) stop('If session_names is provided, it must be of the same length as fname_cifti')
n_sess <- length(fname_cifti)
if(n_sess==1){
if(is.null(session_names)) session_names <- 'single_session'
fname_cifti <- list(fname_cifti)
if(!is.null(design)) design <- list(design)
#if(!is.null(onsets)) onsets <- list(onsets)
if(!is.null(nuisance)) nuisance <- list(nuisance)
} else {
if(is.null(session_names)) session_names <- paste0('session', 1:n_sess)
if(!is.null(design)){ if(length(design) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), design must be a list of length equal to the number of sessions (or NULL, if onsets provided).') }
#if(!is.null(onsets)){ if(length(onsets) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), onsets must be a list of length equal to the number of sessions (or NULL, if design provided).') }
if(!is.null(nuisance)){ if(length(nuisance) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), nuisance must be a list of length equal to the number of sessions (or NULL).') }
}
if(length(session_names) != n_sess) stop('If session_names is provided, it must be of the same length as fname_cifti')
nuisance=NULL
n_sess <- length(fname_cifti)
if(n_sess==1){
if(is.null(session_names)) session_names <- 'single_session'
fname_cifti <- list(fname_cifti)
if(!is.null(design)) design <- list(design)
#if(!is.null(onsets)) onsets <- list(onsets)
if(!is.null(nuisance)) nuisance <- list(nuisance)
} else {
if(is.null(session_names)) session_names <- paste0('session', 1:n_sess)
if(!is.null(design)){ if(length(design) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), design must be a list of length equal to the number of sessions (or NULL, if onsets provided).') }
#if(!is.null(onsets)){ if(length(onsets) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), onsets must be a list of length equal to the number of sessions (or NULL, if design provided).') }
if(!is.null(nuisance)){ if(length(nuisance) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), nuisance must be a list of length equal to the number of sessions (or NULL).') }
}
if(length(session_names) != n_sess) stop('If session_names is provided, it must be of the same length as fname_cifti')
if(do_left) cifti_left <- vector('list', n_sess)
if(do_right) cifti_right <- vector('list', n_sess)
if(do_sub) nifti_data <- nifti_labels <- vector('list', n_sess)
for(ss in 1:n_sess){
cifti_ss <- cifti_read_separate(fname_cifti[[ss]], brainstructures=brainstructures)
cifti_left[[ss]] <- cifti_ss$CORTEX_LEFT
cifti_right[[ss]] <- cifti_ss$CORTEX_RIGHT
nifti_data[[ss]] <- cifti_data_ss$VOL
nifti_labels[[ss]] <- cifti_data_ss$LABELS
}
library(ciftiTools)
if(do_left) cifti_left <- vector('list', n_sess)
if(do_right) cifti_right <- vector('list', n_sess)
if(do_sub) nifti_data <- nifti_labels <- vector('list', n_sess)
for(ss in 1:n_sess){
cifti_ss <- cifti_read_separate(fname_cifti[[ss]], brainstructures=brainstructures)
cifti_left[[ss]] <- cifti_ss$CORTEX_LEFT
cifti_right[[ss]] <- cifti_ss$CORTEX_RIGHT
nifti_data[[ss]] <- cifti_data_ss$VOL
nifti_labels[[ss]] <- cifti_data_ss$LABELS
}
fname_cifti
#location of subject meshes
fname_cifti <- '103818.sess1.tfMRI_MOTOR_RL.10k.dtseries.nii'
list(fname_cifti)
fname_cifti <- list(fname_cifti)
design
design=Z
nuisance=NULL
#location of subject meshes
fname_cifti <- '103818.sess1.tfMRI_MOTOR_RL.10k.dtseries.nii'
fname_gifti_left <- 'data_processed/subject_meshes/103818.L.midthickness.10k.surf.gii'
fname_gifti_right <- 'data_processed/subject_meshes/103818.R.midthickness.10k.surf.gii'
n_sess <- length(fname_cifti)
if(n_sess==1){
if(is.null(session_names)) session_names <- 'single_session'
fname_cifti <- list(fname_cifti)
if(!is.null(design)) design <- list(design)
#if(!is.null(onsets)) onsets <- list(onsets)
if(!is.null(nuisance)) nuisance <- list(nuisance)
} else {
if(is.null(session_names)) session_names <- paste0('session', 1:n_sess)
if(!is.null(design)){ if(length(design) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), design must be a list of length equal to the number of sessions (or NULL, if onsets provided).') }
#if(!is.null(onsets)){ if(length(onsets) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), onsets must be a list of length equal to the number of sessions (or NULL, if design provided).') }
if(!is.null(nuisance)){ if(length(nuisance) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), nuisance must be a list of length equal to the number of sessions (or NULL).') }
}
if(length(session_names) != n_sess) stop('If session_names is provided, it must be of the same length as fname_cifti')
fname_cifti
if(do_left) cifti_left <- vector('list', n_sess)
if(do_right) cifti_right <- vector('list', n_sess)
if(do_sub) nifti_data <- nifti_labels <- vector('list', n_sess)
for(ss in 1:n_sess){
cifti_ss <- cifti_read_separate(fname_cifti[[ss]], brainstructures=brainstructures)
cifti_left[[ss]] <- cifti_ss$CORTEX_LEFT
cifti_right[[ss]] <- cifti_ss$CORTEX_RIGHT
nifti_data[[ss]] <- cifti_data_ss$VOL
nifti_labels[[ss]] <- cifti_data_ss$LABELS
}
fname_cifti[[ss]]
dir
list.files(dir)
dir
cifti_ss <- cifti_read_separate(fname_cifti[[ss]], brainstructures=brainstructures, dir=dir)
cifti_read_separate <- function(fname_cifti, dir=NULL, brainstructures=c('left','right','subcortical'), wb_cmd){
do_left <- ('left' %in% brainstructures)
do_right <- ('right' %in% brainstructures)
do_sub <- ('subcortical' %in% brainstructures)
### Separate the CIFTI file into left cortex, right cortex, subcortical volumetric data, and subcortical labels
extn <- paste(rev(unlist(strsplit(fname_cifti, split='.', fixed = TRUE)))[c(2,1)], collapse='.') #get extension of cifti file (e.g. "dtseries.nii", "dscalar.nii")
if(do_left) fname_left <- gsub(extn,'L.func.gii',fname_cifti, fixed=TRUE)
if(do_right) fname_right <- gsub(extn,'R.func.gii',fname_cifti, fixed=TRUE)
if(do_sub) {
fname_vol <-gsub(extn,'nii.gz',fname_cifti, fixed=TRUE)
fname_labels <- gsub(extn,'labels.nii.gz',fname_cifti, fixed=TRUE)
}
### Check whether separated files already exist
if(is.null(dir)) dir <- getwd()
all_files <- list.files(dir)
if(!(fname_cifti %in% all_files)) stop('fname_cifti does not exist in specified or current working directory')
need_left <- need_right <- need_sub <- FALSE
if(do_left) if(!(fname_left %in% all_files)) need_left <- TRUE
if(do_right) if(!(fname_right %in% all_files)) need_right <- TRUE
if(do_sub) if(!(fname_vol %in% all_files & fname_labels %in% all_files)) need_sub <- TRUE
### Construct system command to create needed files
cmd_left <- cmd_right <- cmd_sub <- NULL
if(need_left) cmd_left <- paste('-metric CORTEX_LEFT', fname_left, sep=' ')
if(need_right) cmd_right <- paste('-metric CORTEX_RIGHT', fname_right, sep=' ')
if(need_sub) cmd_sub <- paste('-volume-all', fname_vol, '-label', fname_labels, sep=' ')
if(need_left | need_right | need_sub){
cmd <- paste(wb_cmd, '-cifti-separate', fname_cifti, 'COLUMN', cmd_left, cmd_right, cmd_sub, sep=' ')
system(cmd)
}
### Read in gifti and nifti files
result <- vector('list', length=4)
names(result) <- c('CORTEX_LEFT','CORTEX_RIGHT','VOL','LABELS')
if(do_left) {
dat_left <- readGIfTI(file.path(dir,fname_left))$data #list of length T, each element of length nvox
nvox <- length(dat_left[[1]])
ntime <- length(dat_left)
result$CORTEX_LEFT <- matrix(unlist(dat_left), nrow=nvox, ncol=ntime) #form data matrix
}
if(do_right) {
dat_left <- readGIfTI(file.path(dir,fname_right))$data #list of length T, each element of length nvox
nvox <- length(dat_left[[1]])
ntime <- length(dat_left)
result$CORTEX_RIGHT <- matrix(unlist(dat_left), nrow=nvox, ncol=ntime) #form data matrix
}
if(do_sub){
result$VOL <- readNIfTI(file.path(dir,fname_vol), reorient=FALSE)
result$LABELS <- readNIfTI(file.path(dir,fname_labels), reorient=FALSE)
}
class(result) <- 'cifti'
return(result)
}
cifti_ss <- cifti_read_separate(fname_cifti[[ss]], brainstructures=brainstructures, dir=dir)
library(gifti)
cifti_ss <- cifti_read_separate(fname_cifti[[ss]], brainstructures=brainstructures, dir=dir)
cifti_left[[ss]] <- cifti_ss$CORTEX_LEFT
cifti_right[[ss]] <- cifti_ss$CORTEX_RIGHT
nifti_data[[ss]] <- cifti_data_ss$VOL
nifti_labels[[ss]] <- cifti_data_ss$LABELS
nifti_data[[ss]] <- cifti_ss$VOL
nifti_labels[[ss]] <- cifti_ss$LABELS
inla.setOption
library(INLA)
inla.setOption
library(devtools)
devtools::install_github("mandymejia/BayesfMRI")
# library(devtools)
# devtools::install_github("mandymejia/BayesfMRI")
library(BayesfMRI)
install.packages(pkgs='~/Box/SOFTWARE/ciftiTools', repos=NULL, type='source')
#install.packages(pkgs='~/Box/SOFTWARE/ciftiTools', repos=NULL, type='source')
# devtools::install_github("mandymejia/ciftiTools")
library(ciftiTools) #dependency of BayesfMRI, so should not need this line eventually
