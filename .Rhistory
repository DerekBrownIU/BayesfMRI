# Check length/dimensions of y, X, elements of betas and repls all match
n_sess <- length(X)
nx <- length(betas) #check same as length(repls)
#figure out nvox
#check dim(X)
#check length of betas and repls
numel <- 1 + length(betas) + length(repls) + 1
model_data <- vector('list', length=numel)
names(model_data) <- c('y', 'X', names(betas), names(repls))
model_data$y <- y
model_data$X <- bdiag(X) #row/col structure: task1_sess1_beta1, task1_sess1_beta2, task1_sess2_beta1, task1_sess2_beta2, ..., task2_sess1_beta1, ...
nbeta <- length(betas)
for(i in 1:nbeta){
model_data[[2+i]] <- betas[[i]]
model_data[[2+nbeta+i]] <- repls[[i]]
}
return(model_data)
}
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
INLA_result <- estimate_model(formula=formula, data=model_data, A=model_data$X, prec_initial=1)
#extract useful stuff from INLA model result
session_names <- names(X_all_list)
session_names
#extract useful stuff from INLA model result
beta_means <- extract_estimates(object=INLA_result, mask=mask, session_names=session_names) #posterior means of latent task field
length(mask)
object=INLA_result
class(object)
res.beta <- object$summary.random
nbeta <- length(res.beta)
beta_names <- names(res.beta)
beta_names
nvox2 <- sum(mask)
n_sess <- length(session_names)
n_sess
session_names
length(res.beta[[1]]$mean)
V
mesh$n
betas <- vector('list', n_sess)
names(betas) <- session_names
v=1
sess_name <- session_names[v]
sess_name
nmesh <- mesh$n
betas <- vector('list', n_sess)
names(betas) <- session_names
sess_name <- session_names[v]
inds_v <- (1:nmesh) + (v-1)*nmesh #indices of beta vector corresponding to session v
(v-1)*nmesh
nmesh
length(res.beta)
extract_estimates <- function(object, mesh, session_names){
if(class(object) != "inla"){
stop("Object is not of class 'inla'")
}
res.beta <- object$summary.random
nbeta <- length(res.beta)
beta_names <- names(res.beta)
nmesh <- mesh$n
n_sess <- length(session_names)
betas <- vector('list', n_sess)
names(betas) <- session_names
for(v in 1:n_sess){
sess_name <- session_names[v]
inds_v <- (1:nmesh) + (v-1)*nmesh #indices of beta vector corresponding to session v
betas_v <- matrix(NA, nrow=nmesh, ncol=nbeta)
for(i in 1:nbeta){
est_iv <- res.beta[[i]]$mean[inds_v]
betas_v[,i] <- est_iv
}
betas[[v]] <- betas_v
}
return(betas)
}
#extract useful stuff from INLA model result
beta_means <- extract_estimates(object=INLA_result, mesh=mesh, session_names=session_names) #posterior means of latent task field
class(beta_means)
class(beta_means[[1]])
dim(beta_means[[1]])
names(mesh)
Amat <- inla.spde.make.A(mesh)
dim(Amat)
Amat <- inla.spde.make.A(mesh, loc=vertices)
xy.in <- which(mask3D==1, arr.ind=TRUE)[,2:1]
head(xy.in)
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
plot(mesh)
Amat <- inla.spde.make.A(mesh, loc=xy.in)
dim(Amat)
dim(beta_means[[1]])
theta_posteriors <- get_posterior_densities(INLA_result, spde, names(betas)) #hyperparameter posterior densities
beta_names
b='bbeta1'
result.spde.b = inla.spde2.result(object, b, spde)
# Kappa and Tau
log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
log_kappa.b$param <- 'log_kappa'
log_tau.b$param <- 'log_tau'
df.b <- rbind(log_kappa.b, log_tau.b)
df.b$beta <- b
if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
names(df)
get_posterior_densities <- function(object, spde, beta_names){
for(b in beta_names){
result.spde.b = inla.spde2.result(object, b, spde)
# Kappa and Tau
log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
log_kappa.b$param <- 'log_kappa'
log_tau.b$param <- 'log_tau'
df.b <- rbind(log_kappa.b, log_tau.b)
df.b$beta <- b
if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
}
df <- df[,c('beta','param','value','density')]
return(df)
}
theta_posteriors <- get_posterior_densities(object=INLA_result, spde, names(betas)) #hyperparameter posterior densities
for(b in beta_names){
result.spde.b = inla.spde2.result(object, b, spde)
# Kappa and Tau
log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
log_kappa.b$param <- 'log_kappa'
log_tau.b$param <- 'log_tau'
df.b <- rbind(log_kappa.b, log_tau.b)
df.b$beta <- b
if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
}
object=INLA_result
beta_names
get_posterior_densities <- function(object, spde, beta_names){
for(b in beta_names){
result.spde.b = inla.spde2.result(object, b, spde)
# Kappa and Tau
log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
log_kappa.b$param <- 'log_kappa'
log_tau.b$param <- 'log_tau'
df.b <- rbind(log_kappa.b, log_tau.b)
df.b$beta <- b
if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
}
df <- df[,c('beta','param','value','density')]
return(df)
}
theta_posteriors <- get_posterior_densities(object=INLA_result, spde, names(betas)) #hyperparameter posterior densities
image(Amat)
Amat[1:10,1:10]
print(names(result.spde.b))
get_posterior_densities <- function(object, spde, beta_names){
for(b in beta_names){
result.spde.b = inla.spde2.result(object, b, spde)
print(names(result.spde.b))
# # Kappa and Tau
# log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
# log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
# names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
# log_kappa.b$param <- 'log_kappa'
# log_tau.b$param <- 'log_tau'
# df.b <- rbind(log_kappa.b, log_tau.b)
# df.b$beta <- b
# if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
}
# df <- df[,c('beta','param','value','density')]
# return(df)
}
theta_posteriors <- get_posterior_densities(object=INLA_result, spde, names(betas)) #hyperparameter posterior densities
get_posterior_densities <- function(object, spde, beta_names){
for(b in beta_names){
print(b)
result.spde.b = inla.spde2.result(object, b, spde)
print(names(result.spde.b))
# # Kappa and Tau
# log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
# log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
# names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
# log_kappa.b$param <- 'log_kappa'
# log_tau.b$param <- 'log_tau'
# df.b <- rbind(log_kappa.b, log_tau.b)
# df.b$beta <- b
# if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
}
# df <- df[,c('beta','param','value','density')]
# return(df)
}
theta_posteriors <- get_posterior_densities(object=INLA_result, spde, names(betas)) #hyperparameter posterior densities
names(betas)
names(replicates_list$betas)
betas <- replicates_list$betas
repls <- replicates_list$repls
theta_posteriors <- get_posterior_densities(object=INLA_result, spde, names(betas)) #hyperparameter posterior densities
get_posterior_densities <- function(object, spde, beta_names){
for(b in beta_names){
result.spde.b = inla.spde2.result(object, b, spde)
# Kappa and Tau
log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
log_kappa.b$param <- 'log_kappa'
log_tau.b$param <- 'log_tau'
df.b <- rbind(log_kappa.b, log_tau.b)
df.b$beta <- b
if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
}
df <- df[,c('beta','param','value','density')]
return(df)
}
theta_posteriors <- get_posterior_densities(object=INLA_result, spde, names(betas)) #hyperparameter posterior densities
names(theta_posteriors)
head(theta_posteriors)
res.beta <- object$summary.random
nbeta <- length(res.beta)
beta_names <- names(res.beta)
names(res.beta)
length(res.beta[[1]])
length(res.beta[[1]]$mean)
names(res.beta[[1]])
stat='mean'
stat_ind <- which(names(res.beta[[i]])==stat)
i=1
stat_ind <- which(names(res.beta[[i]])==stat)
stat_ind
head(est_iv)
est_iv <- res.beta[[i]]$mean[inds_v]
head(est_iv)
est_iv <- res.beta[[i]][[stat_ind]][inds_v]
head(est_iv)
n_sess
class(beta_means)
class(beta_means[[1]])
length(beta_means)
head(beta_means[[1]])
stat_names <- names(res.beta[[1]])
stat_names
head(res.beta[[1]]$ID)
head(res.beta[[1]]$sd)
head(res.beta[[1]]$mode)
head(res.beta[[1]]$kld)
stat_names <- names(res.beta[[1]])
paste0('stat must be one of following: ' paste(stat_names, collapse = ', '))
paste0('stat must be one of following: ', paste(stat_names, collapse = ', '))
extract_estimates <- function(object, session_names, stat='mean'){
if(class(object) != "inla"){
stop("Object is not of class 'inla'")
}
res.beta <- object$summary.random
nbeta <- length(res.beta)
beta_names <- names(res.beta)
n_sess <- length(session_names)
n_loc <- length(res.beta[[1]]$mean)/n_sess
betas <- vector('list', n_sess)
names(betas) <- session_names
stat_names <- names(res.beta[[1]])
if(! (stat %in% stat_names) ) stop(paste0('stat must be one of following: ', paste(stat_names, collapse = ', ')))
stat_ind <- which(stat_names==stat)
for(v in 1:n_sess){
inds_v <- (1:n_loc) + (v-1)*n_loc #indices of beta vector corresponding to session v
betas_v <- matrix(NA, nrow=n_loc, ncol=nbeta)
colnames(betas_v) <- beta_names
for(i in 1:nbeta){
est_iv <- res.beta[[i]][[stat_ind]][inds_v]
betas_v[,i] <- est_iv
}
betas[[v]] <- betas_v
}
return(betas)
}
#extract useful stuff from INLA model result
beta_means <- extract_estimates(object=INLA_result, session_names=session_names) #posterior means of latent task field
head(beta_means[[1]])
#extract useful stuff from INLA model result
beta_means <- extract_estimates(object=INLA_result, session_names=session_names, stat='mode') #posterior means of latent task field
head(beta_means[[1]])
#extract useful stuff from INLA model result
beta_means <- extract_estimates(object=INLA_result, session_names=session_names) #posterior means of latent task field
names(result.spde.b)
names(object)
sapply(object, "class")
class(spde)
is.spde(spde)
get_posterior_densities <- function(object, spde){
beta_names <- names(object$summary.random)
for(b in beta_names){
result.spde.b = inla.spde2.result(object, b, spde)
# Kappa and Tau
log_kappa.b = as.data.frame(result.spde.b$marginals.log.kappa$kappa.1)
log_tau.b = as.data.frame(result.spde.b$marginals.log.tau$tau.1)
names(log_kappa.b) <- names(log_tau.b) <- c('value','density')
log_kappa.b$param <- 'log_kappa'
log_tau.b$param <- 'log_tau'
df.b <- rbind(log_kappa.b, log_tau.b)
df.b$beta <- b
if(b==beta_names[1]) df <- df.b else df <- rbind(df, df.b)
}
df <- df[,c('beta','param','value','density')]
return(df)
}
model(INLA_result)
INLA_result$forula
INLA_result$formula
getwd()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
## Read in the mask
mask <- as.matrix(read.table("example/Mask"))
mask2 <- as.matrix(read.table("example/Mask2"))
mask3D <- mask*mask2
## Create a mesh using inla.mesh.2d
xy.in <- which(mask3D==1, arr.ind=TRUE)[,2:1]
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
## Create a matrix to translate between original and mesh locations
Amat <- inla.spde.make.A(mesh, loc=xy.in)
## Read in timeseries data
dat <- as.matrix(read.csv('example/FWHM20_NoisyData_1.csv', header=FALSE))
## Construct design matrix
z1 <- as.matrix(read.table('example/Z1.txt'))
z2 <- as.matrix(read.table('example/Z2.txt'))
Z <- cbind(z1, z2)
## Build session data
session <- list(BOLD = dat, design = Z)
is.session(session)
data <- list(single_session = session)
rm(vertices)
rm(faces)
rm(mask)
scale=TRUE
#check that all elements of the data list are valid sessions and have the same number of locations and tasks
session_names <- names(data)
session_names
n_sess <- length(session_names)
V
V <- ncol(data[[1]]$BOLD)
V
dim(Amat)
spde <- inla.spde2.matern(mesh)
n_sess
y_all <- c()
X_all_list <- NULL
for(s in 1:n_sess){
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
if(!missing(mask)) BOLD_s <- BOLD_s[,mask==1]
#scale data to represent % signal change
BOLD_s <- scale_timeseries(t(BOLD_s))
#regress nuisance parameters from BOLD data and design matrix
if('nuisance' %in% names(data[[s]])){
design_s <- data[[s]]$design
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- data[[s]]$design
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
y_all <- c()
X_all_list <- NULL
for(s in 1:n_sess){
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
#scale data to represent % signal change
BOLD_s <- scale_timeseries(t(BOLD_s))
#regress nuisance parameters from BOLD data and design matrix
if('nuisance' %in% names(data[[s]])){
design_s <- data[[s]]$design
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- data[[s]]$design
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
length(y_all)
length(X_all_list)
length(X_all_list[[1]])
dim(X_all_list[[1]])
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
head(betas[[1]])
head(betas[[2]])
head(repls[[1]])
head(repls[[2]])
#organize the formula and data objects
formula <- make_formula(beta_names = names(betas), repl_names = names(repls), model_name = 'spde', hyper_initial = c(-2,2))
formula
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
INLA_result <- estimate_model(formula=formula, data=model_data, A=model_data$X, prec_initial=1)
formula$environment
names(formula)
class(formula)
environment(formula)
BayesGLMfMRI <- function(data, vertices, faces, mesh, mask, scale=TRUE){
#check whether data is a list OR a session (for single-session analysis)
#check whether each element of data is a session (use is.session)
# V0 = full number of data locations
# V = masked number of data locations
# T = length of time series for each session (vector)
# K = number of unique tasks in all sessions
#need to check that sessions are consistent in terms of V, K?
#INLA:::inla.dynload.workaround() #avoid error on creating mesh
#check that only mesh OR vertices+faces supplied
has_mesh <- !missing(mesh)
has_verts_faces <- !missing(vertices) & !missing(faces)
has_howmany <- has_mesh + has_verts_faces
if(has_howmany != 1) stop('Must supply EITHER mesh OR vertices and faces.')
#maybe also allow the user to supply a mesh object
#if mesh and mask both supplied, will need to deal with that...
#check that all elements of the data list are valid sessions and have the same number of locations and tasks
session_names <- names(data)
n_sess <- length(session_names)
if(!is.list(data)) stop('I expect data to be a list, but it is not')
data_classes <- sapply(data, 'class')
if(! all.equal(unique(data_classes),'list')) stop('I expect data to be a list of lists (sessions), but it is not')
V <- ncol(data[[1]]$BOLD)
K <- ncol(data[[1]]$design)
for(s in 1:n_sess){
if(! is.session(data[[s]])) stop('I expect each element of data to be a session object, but at least one is not (see `is.session`).')
if(ncol(data[[s]]$BOLD) != V) stop('All sessions must have the same number of data locations, but they do not.')
if(ncol(data[[s]]$design) != K) stop('All sessions must have the same number of tasks (columns of the design matrix), but they do not.')
}
if(missing(mesh)) {
if(missing(mask)) mesh <- make_mesh(vertices, faces)
if(!missing(mask)) mesh <- make_mesh(vertices, faces, mask)
}
spde <- inla.spde2.matern(mesh)
#areas <- compute_vertex_areas(mesh)
#collect data and design matrices
y_all <- c()
X_all_list <- NULL
for(s in 1:n_sess){
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
if(!missing(mask)) BOLD_s <- BOLD_s[,mask==1]
#scale data to represent % signal change
BOLD_s <- scale_timeseries(t(BOLD_s))
#regress nuisance parameters from BOLD data and design matrix
if('nuisance' %in% names(data[[s]])){
design_s <- data[[s]]$design
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- data[[s]]$design
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
#organize the formula and data objects
formula <- make_formula(beta_names = names(betas), repl_names = names(repls), model_name = 'spde', hyper_initial = c(-2,2))
environment(formula) <- globalenv()
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
INLA_result <- estimate_model(formula=formula, data=model_data, A=model_data$X, prec_initial=1)
#extract useful stuff from INLA model result
beta_estimates <- extract_estimates(object=INLA_result, session_names=session_names) #posterior means of latent task field
theta_posteriors <- get_posterior_densities(object=INLA_result, spde) #hyperparameter posterior densities
#identify areas of activation if activation threshold(s) specified by user
#construct object to be returned
result <- list(model=INLA_result, mesh=mesh, sessions=session_names, beta_estimates=beta_estimates, theta_posteriors=theta_posteriors)
return(result)
}
result <- BayesGLMfMRI(data, mesh=mesh)
names(result)
help(make_formula)
library(BayesGLMfMRI)
install.packages('mandymejia/BayesGLMfMRI')
library(devtools)
install_github('mandymejia/BayesGLMfMRI')
help(make_formula)
make_formula
