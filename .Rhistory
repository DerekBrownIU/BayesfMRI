if (!transpose) {
BOLD <- t(BOLD)
}
BOLD
}
eps1 = max(abs( x_sBOLD_sFALSE - normalize_BOLD(x, "both", "none") ))
eps2 = max(abs( x_sBOLD_sTRUE - normalize_BOLD(x, "both", "sd") ))
#' Center BOLD data across space and/or time and scale (optionally)
#'
#' @param BOLD (TxV matrix) fMRI timeseries data matrix
#' @param center One of \code{space_across} (Default) (center across space: center the volume at each time point based on the mean of its image), \code{time_across} (center across time: centers the time course for each voxel based on the mean of its intensity), and \code{both}.
#' @param vox_scale One of \code{none} (Default) (Do not do any scaling, only centering), \code{sd} (Divide each voxel's time course by its standard deviation), and \code{pct} (Multiply each voxel's time course by \code{100/m}, where \code{m} is the mean of the voxel's time course. This is equivalent to scaling each voxel time series to units of percent local signal change.).
#' @param transpose Transpose the data matrix? Default: \code{FALSE}.
#'
#' @return Centered and scaled BOLD data (TxV matrix)
#' @export
#'
#' @details
#'
#' On centering:
#'
#' Centering across space will remove the global signal. Centering across time will remove the mean image of each voxel time series. Both
#' are necessary for dual regression, which in the first regression treats time points as observations, and in the second step treats voxels
#' as observations. Neither regression includes an intercept, so the BOLD timeseries must be centered across both space and time. The group
#' independent components used in the first regression must also be centered across space. The mixing matrix estimated in the first step of
#' dual regression is also centered across time as a result.
#'
#'
#' On scaling:
#'
#' In order to ensure that all fMRI data share the same scale, the BOLD data can also be scaled by the global image standard deviation, equal to
#' \deqn{\sqrt{\frac{1}{T}\sum_{t=1}^T \sigma^2_t}},
#' where \eqn{\sigma^2_t} is the standard deviation across all voxels at time point \eqn{t}. If scaling is applied to the BOLD timeseries used in
#' template estimation, it should also be applied to the BOLD timeseries being analyzed with template ICA using the resulting templates to ensure
#' compatibility of scale. The option for scaling by global image standard deviation is \code{vox_scale="sd"}.
#'
#' Alternatively, to scale such that each voxel time series indicates its percent signal change, use \code{vox_scale="pct"}.
normalize_BOLD <- function(BOLD,
center=c("space_across", "time_across", "both"),
vox_scale=c("none", "sd", "pct"),
transpose=FALSE){
center <- match.arg(center, c("space_across", "time_across", "both"))
vox_scale <- match.arg(vox_scale, c("none", "sd", "pct"))
BOLD <- as.matrix(BOLD)
T_ <- nrow(BOLD)
V_ <- ncol(BOLD)
if (T_ > V_) {
warning("BOLD should be TxV, but input had more rows than columns. Are you sure?")
}
# Centering.
timeMeans <- rowMeans(BOLD, na.rm=TRUE)
#   Subtract mean across space for each time point/volume.
if (center %in% c("space_across", "both")){
BOLD <- BOLD - timeMeans
}
#   Vector recycling occurs along the rows, so we need to transpose.
BOLD <- t(BOLD)
#   Subtract mean across time for each voxel.
voxMeans <- rowMeans(BOLD, na.rm=TRUE)
if (center %in% c("time_across", "both")){
BOLD <- BOLD - voxMeans
}
# Scaling.
#   Scale each voxel time series by the global image SD.
if (vox_scale=="sd") {
BOLD <- BOLD / sqrt(mean(colVars(BOLD)))
#   Scale each voxel time series to units of pct local signal change.
} else if (vox_scale=="pct") {
BOLD <- BOLD * 100 / voxMeans
}
# The data was transposed during centering--transpose again to yield original dimensions.
if (!transpose) {
BOLD <- t(BOLD)
}
BOLD
}
eps1 = max(abs( x_sBOLD_sFALSE - normalize_BOLD(x, "both", "none") ))
eps2 = max(abs( x_sBOLD_sTRUE - normalize_BOLD(x, "both", "sd") ))
# install.packages("mandymejia/BayesfMRI")
library(BayesfMRI)
v <- c(2,5,10)
t <- 30
x <- array(rnorm(prod(v)*t), c(t, prod(v)))
x_sBOLD_sTRUE <- BayesfMRI::scale_BOLD(x, scale=TRUE)
x_sBOLD_sFALSE <- BayesfMRI::scale_BOLD(x, scale=FALSE)
x_sTS_sTRUE <- BayesfMRI::scale_timeseries(t(x), scale=TRUE, transpose=FALSE)
x_sTS_sFALSE <- BayesfMRI::scale_timeseries(t(x), scale=FALSE, transpose=FALSE)
#' Center BOLD data across space and/or time and scale (optionally)
#'
#' @param BOLD (TxV matrix) fMRI timeseries data matrix
#' @param center One of \code{space_across} (Default) (center across space: center the volume at each time point based on the mean of its image), \code{time_across} (center across time: centers the time course for each voxel based on the mean of its intensity), and \code{both}.
#' @param vox_scale One of \code{none} (Default) (Do not do any scaling, only centering), \code{sd} (Divide each voxel's time course by its standard deviation), and \code{pct} (Multiply each voxel's time course by \code{100/m}, where \code{m} is the mean of the voxel's time course. This is equivalent to scaling each voxel time series to units of percent local signal change.).
#' @param transpose Transpose the data matrix? Default: \code{FALSE}.
#'
#' @return Centered and scaled BOLD data (TxV matrix)
#' @export
#'
#' @details
#'
#' On centering:
#'
#' Centering across space will remove the global signal. Centering across time will remove the mean image of each voxel time series. Both
#' are necessary for dual regression, which in the first regression treats time points as observations, and in the second step treats voxels
#' as observations. Neither regression includes an intercept, so the BOLD timeseries must be centered across both space and time. The group
#' independent components used in the first regression must also be centered across space. The mixing matrix estimated in the first step of
#' dual regression is also centered across time as a result.
#'
#'
#' On scaling:
#'
#' In order to ensure that all fMRI data share the same scale, the BOLD data can also be scaled by the global image standard deviation, equal to
#' \deqn{\sqrt{\frac{1}{T}\sum_{t=1}^T \sigma^2_t}},
#' where \eqn{\sigma^2_t} is the standard deviation across all voxels at time point \eqn{t}. If scaling is applied to the BOLD timeseries used in
#' template estimation, it should also be applied to the BOLD timeseries being analyzed with template ICA using the resulting templates to ensure
#' compatibility of scale. The option for scaling by global image standard deviation is \code{vox_scale="sd"}.
#'
#' Alternatively, to scale such that each voxel time series indicates its percent signal change, use \code{vox_scale="pct"}.
normalize_BOLD <- function(BOLD,
center=c("space_across", "time_across", "both"),
vox_scale=c("none", "sd", "pct"),
transpose=FALSE){
center <- match.arg(center, c("space_across", "time_across", "both"))
vox_scale <- match.arg(vox_scale, c("none", "sd", "pct"))
BOLD <- as.matrix(BOLD)
T_ <- nrow(BOLD)
V_ <- ncol(BOLD)
if (T_ > V_) {
warning("BOLD should be TxV, but input had more rows than columns. Are you sure?")
}
# Centering.
timeMeans <- rowMeans(BOLD, na.rm=TRUE)
#   Subtract mean across space for each time point/volume.
if (center %in% c("space_across", "both")){
BOLD <- BOLD - timeMeans
}
#   Vector recycling occurs along the rows, so we need to transpose.
BOLD <- t(BOLD)
#   Subtract mean across time for each voxel.
voxMeans <- rowMeans(BOLD, na.rm=TRUE)
if (center %in% c("time_across", "both")){
BOLD <- BOLD - voxMeans
}
# Scaling.
#   Scale each voxel time series by the global image SD.
if (vox_scale=="sd") {
BOLD <- BOLD / sqrt(mean(colVars(BOLD)))
#   Scale each voxel time series to units of pct local signal change.
} else if (vox_scale=="pct") {
BOLD <- BOLD * 100 / voxMeans
}
# The data was transposed during centering--transpose again to yield original dimensions.
if (!transpose) {
BOLD <- t(BOLD)
}
BOLD
}
eps1 = max(abs( x_sBOLD_sFALSE - normalize_BOLD(x, "both", "none") ))
eps2 = max(abs( x_sBOLD_sTRUE - normalize_BOLD(x, "both", "sd") ))
?colVars
#' Center BOLD data across space and/or time and scale (optionally)
#'
#' @param BOLD (TxV matrix) fMRI timeseries data matrix
#' @param center One of \code{space_across} (Default) (center across space: center the volume at each time point based on the mean of its image), \code{time_across} (center across time: centers the time course for each voxel based on the mean of its intensity), and \code{both}.
#' @param vox_scale One of \code{none} (Default) (Do not do any scaling, only centering), \code{sd} (Divide each voxel's time course by its standard deviation), and \code{pct} (Multiply each voxel's time course by \code{100/m}, where \code{m} is the mean of the voxel's time course. This is equivalent to scaling each voxel time series to units of percent local signal change.).
#' @param transpose Transpose the data matrix? Default: \code{FALSE}.
#'
#' @return Centered and scaled BOLD data (TxV matrix)
#' @export
#'
#' @details
#'
#' On centering:
#'
#' Centering across space will remove the global signal. Centering across time will remove the mean image of each voxel time series. Both
#' are necessary for dual regression, which in the first regression treats time points as observations, and in the second step treats voxels
#' as observations. Neither regression includes an intercept, so the BOLD timeseries must be centered across both space and time. The group
#' independent components used in the first regression must also be centered across space. The mixing matrix estimated in the first step of
#' dual regression is also centered across time as a result.
#'
#'
#' On scaling:
#'
#' In order to ensure that all fMRI data share the same scale, the BOLD data can also be scaled by the global image standard deviation, equal to
#' \deqn{\sqrt{\frac{1}{T}\sum_{t=1}^T \sigma^2_t}},
#' where \eqn{\sigma^2_t} is the standard deviation across all voxels at time point \eqn{t}. If scaling is applied to the BOLD timeseries used in
#' template estimation, it should also be applied to the BOLD timeseries being analyzed with template ICA using the resulting templates to ensure
#' compatibility of scale. The option for scaling by global image standard deviation is \code{vox_scale="sd"}.
#'
#' Alternatively, to scale such that each voxel time series indicates its percent signal change, use \code{vox_scale="pct"}.
normalize_BOLD <- function(BOLD,
center=c("space_across", "time_across", "both"),
vox_scale=c("none", "sd", "pct"),
transpose=FALSE){
center <- match.arg(center, c("space_across", "time_across", "both"))
vox_scale <- match.arg(vox_scale, c("none", "sd", "pct"))
BOLD <- as.matrix(BOLD)
T_ <- nrow(BOLD)
V_ <- ncol(BOLD)
if (T_ > V_) {
warning("BOLD should be TxV, but input had more rows than columns. Are you sure?")
}
# Centering.
timeMeans <- rowMeans(BOLD, na.rm=TRUE)
#   Subtract mean across space for each time point/volume.
if (center %in% c("space_across", "both")){
BOLD <- BOLD - timeMeans
}
#   Vector recycling occurs along the rows, so we need to transpose.
BOLD <- t(BOLD)
#   Subtract mean across time for each voxel.
voxMeans <- rowMeans(BOLD, na.rm=TRUE)
if (center %in% c("time_across", "both")){
BOLD <- BOLD - voxMeans
}
# Scaling.
#   Scale each voxel time series by the global image SD.
if (vox_scale=="sd") {
BOLD <- BOLD / sqrt(mean(apply(BOLD, 2, var, na.rm=TRUE)))
#   Scale each voxel time series to units of pct local signal change.
} else if (vox_scale=="pct") {
BOLD <- BOLD * 100 / voxMeans
}
# The data was transposed during centering--transpose again to yield original dimensions.
if (!transpose) {
BOLD <- t(BOLD)
}
BOLD
}
eps1 = max(abs( x_sBOLD_sFALSE - normalize_BOLD(x, "both", "none") ))
eps2 = max(abs( x_sBOLD_sTRUE - normalize_BOLD(x, "both", "sd") ))
eps3 = max(abs( x_sTS_sFALSE - normalize_BOLD(x, "time", "none") ))
eps4 = max(abs( x_sTS_sTRUE - normalize_BOLD(x, "time", "pct") ))
max(c(eps1, eps2, eps3, eps4))
# install.packages("mandymejia/BayesfMRI")
library(BayesfMRI)
v <- c(2,5,10)
t <- 30
x <- array(rnorm(prod(v)*t), c(t, prod(v)))
x_sBOLD_sTRUE <- BayesfMRI::scale_BOLD(x, scale=TRUE)
x_sBOLD_sFALSE <- BayesfMRI::scale_BOLD(x, scale=FALSE)
x_sTS_sTRUE <- BayesfMRI::scale_timeseries(t(x), scale=TRUE, transpose=FALSE)
x_sTS_sFALSE <- BayesfMRI::scale_timeseries(t(x), scale=FALSE, transpose=FALSE)
#' Center BOLD data across space and/or time and scale (optionally)
#'
#' @param BOLD (TxV matrix) fMRI timeseries data matrix
#' @param center One of \code{space_across} (Default) (center across space: center the volume at each time point based on the mean of its image), \code{time_across} (center across time: centers the time course for each voxel based on the mean of its intensity), and \code{both}.
#' @param vox_scale One of \code{none} (Default) (Do not do any scaling, only centering), \code{sd} (Divide each voxel's time course by its standard deviation), and \code{pct} (Multiply each voxel's time course by \code{100/m}, where \code{m} is the mean of the voxel's time course. This is equivalent to scaling each voxel time series to units of percent local signal change.).
#' @param transpose Transpose the data matrix? Default: \code{FALSE}.
#'
#' @return Centered and scaled BOLD data (TxV matrix)
#' @export
#'
#' @details
#'
#' On centering:
#'
#' Centering across space will remove the global signal. Centering across time will remove the mean image of each voxel time series. Both
#' are necessary for dual regression, which in the first regression treats time points as observations, and in the second step treats voxels
#' as observations. Neither regression includes an intercept, so the BOLD timeseries must be centered across both space and time. The group
#' independent components used in the first regression must also be centered across space. The mixing matrix estimated in the first step of
#' dual regression is also centered across time as a result.
#'
#'
#' On scaling:
#'
#' In order to ensure that all fMRI data share the same scale, the BOLD data can also be scaled by the global image standard deviation, equal to
#' \deqn{\sqrt{\frac{1}{T}\sum_{t=1}^T \sigma^2_t}},
#' where \eqn{\sigma^2_t} is the standard deviation across all voxels at time point \eqn{t}. If scaling is applied to the BOLD timeseries used in
#' template estimation, it should also be applied to the BOLD timeseries being analyzed with template ICA using the resulting templates to ensure
#' compatibility of scale. The option for scaling by global image standard deviation is \code{vox_scale="sd"}.
#'
#' Alternatively, to scale such that each voxel time series indicates its percent signal change, use \code{vox_scale="pct"}.
normalize_BOLD <- function(BOLD,
center=c("space_across", "time_across", "both"),
vox_scale=c("none", "sd", "pct"),
transpose=FALSE){
center <- match.arg(center, c("space_across", "time_across", "both"))
vox_scale <- match.arg(vox_scale, c("none", "sd", "pct"))
BOLD <- as.matrix(BOLD)
T_ <- nrow(BOLD)
V_ <- ncol(BOLD)
if (T_ > V_) {
warning("BOLD should be TxV, but input had more rows than columns. Are you sure?")
}
# Centering.
timeMeans <- rowMeans(BOLD, na.rm=TRUE)
#   Subtract mean across space for each time point/volume.
if (center %in% c("space_across", "both")){
BOLD <- BOLD - timeMeans
}
#   Vector recycling occurs along the rows, so we need to transpose.
BOLD <- t(BOLD)
#   Subtract mean across time for each voxel.
voxMeans <- rowMeans(BOLD, na.rm=TRUE)
if (center %in% c("time_across", "both")){
BOLD <- BOLD - voxMeans
}
# Scaling.
#   Scale each voxel time series by the global image SD.
if (vox_scale=="sd") {
BOLD <- BOLD / sqrt(mean(apply(BOLD, 2, var, na.rm=TRUE)))
#   Scale each voxel time series to units of pct local signal change.
} else if (vox_scale=="pct") {
BOLD <- BOLD * 100 / voxMeans
}
# The data was transposed during centering--transpose again to yield original dimensions.
if (!transpose) {
BOLD <- t(BOLD)
}
BOLD
}
eps1 = max(abs( x_sBOLD_sFALSE - normalize_BOLD(x, "both", "none") ))
eps2 = max(abs( x_sBOLD_sTRUE - normalize_BOLD(x, "both", "sd") ))
eps3 = max(abs( x_sTS_sFALSE - normalize_BOLD(x, "time", "none") ))
eps4 = max(abs( x_sTS_sTRUE - normalize_BOLD(x, "time", "pct") ))
max(c(eps1, eps2, eps3, eps4))
# install.packages("mandymejia/BayesfMRI")
library(BayesfMRI)
v <- c(2,5,10)
t <- 30
x <- array(rnorm(prod(v)*t), c(t, prod(v)))
x_sBOLD_sTRUE <- BayesfMRI::scale_BOLD(x, scale=TRUE)
x_sBOLD_sFALSE <- BayesfMRI::scale_BOLD(x, scale=FALSE)
x_sTS_sTRUE <- BayesfMRI::scale_timeseries(t(x), scale=TRUE, transpose=FALSE)
x_sTS_sFALSE <- BayesfMRI::scale_timeseries(t(x), scale=FALSE, transpose=FALSE)
#' Center BOLD data across space and/or time and scale (optionally)
#'
#' @param BOLD (TxV matrix) fMRI timeseries data matrix
#' @param center One of \code{space_across} (Default) (center across space: center the volume at each time point based on the mean of its image), \code{time_across} (center across time: centers the time course for each voxel based on the mean of its intensity), and \code{both}.
#' @param vox_scale One of \code{none} (Default) (Do not do any scaling, only centering), \code{sd} (Divide each voxel's time course by its standard deviation), and \code{pct} (Multiply each voxel's time course by \code{100/m}, where \code{m} is the mean of the voxel's time course. This is equivalent to scaling each voxel time series to units of percent local signal change.).
#' @param transpose Transpose the data matrix? Default: \code{FALSE}.
#'
#' @return Centered and scaled BOLD data (TxV matrix)
#' @export
#'
#' @details
#'
#' On centering:
#'
#' Centering across space will remove the global signal. Centering across time will remove the mean image of each voxel time series. Both
#' are necessary for dual regression, which in the first regression treats time points as observations, and in the second step treats voxels
#' as observations. Neither regression includes an intercept, so the BOLD timeseries must be centered across both space and time. The group
#' independent components used in the first regression must also be centered across space. The mixing matrix estimated in the first step of
#' dual regression is also centered across time as a result.
#'
#'
#' On scaling:
#'
#' In order to ensure that all fMRI data share the same scale, the BOLD data can also be scaled by the global image standard deviation, equal to
#' \deqn{\sqrt{\frac{1}{T}\sum_{t=1}^T \sigma^2_t}},
#' where \eqn{\sigma^2_t} is the standard deviation across all voxels at time point \eqn{t}. If scaling is applied to the BOLD timeseries used in
#' template estimation, it should also be applied to the BOLD timeseries being analyzed with template ICA using the resulting templates to ensure
#' compatibility of scale. The option for scaling by global image standard deviation is \code{vox_scale="sd"}.
#'
#' Alternatively, to scale such that each voxel time series indicates its percent signal change, use \code{vox_scale="pct"}.
normalize_BOLD <- function(BOLD,
center=c("space_across", "time_across", "both"),
vox_scale=c("none", "sd", "pct"),
transpose=FALSE){
center <- match.arg(center, c("space_across", "time_across", "both"))
vox_scale <- match.arg(vox_scale, c("none", "sd", "pct"))
BOLD <- as.matrix(BOLD)
T_ <- nrow(BOLD)
V_ <- ncol(BOLD)
if (T_ > V_) {
warning("BOLD should be TxV, but input had more rows than columns. Are you sure?")
}
# Centering.
timeMeans <- rowMeans(BOLD, na.rm=TRUE)
#   Subtract mean across space for each time point/volume.
if (center %in% c("space_across", "both")){
BOLD <- BOLD - timeMeans
}
#   Vector recycling occurs along the rows, so we need to transpose.
BOLD <- t(BOLD)
#   Subtract mean across time for each voxel.
voxMeans <- rowMeans(BOLD, na.rm=TRUE)
if (center %in% c("time_across", "both")){
BOLD <- BOLD - voxMeans
}
# Scaling.
#   Scale each voxel time series by the global image SD.
if (vox_scale=="sd") {
BOLD <- BOLD / sqrt(mean(apply(BOLD, 2, var, na.rm=TRUE)))
#   Scale each voxel time series to units of pct local signal change.
} else if (vox_scale=="pct") {
BOLD <- BOLD * 100 / voxMeans
}
# The data was transposed during centering--transpose again to yield original dimensions.
if (!transpose) {
BOLD <- t(BOLD)
}
BOLD
}
eps1 = max(abs( x_sBOLD_sFALSE - normalize_BOLD(x, "both", "none") ))
eps2 = max(abs( x_sBOLD_sTRUE - normalize_BOLD(x, "both", "sd") ))
eps3 = max(abs( x_sTS_sFALSE - normalize_BOLD(x, "time", "none") ))
eps4 = max(abs( x_sTS_sTRUE - normalize_BOLD(x, "time", "pct") ))
max(c(eps1, eps2, eps3, eps4))
U <- matrix(rnorm(600), nrow=6)
lev <- diag(U %*% t(U))
rowNorms(U)
apply(U, 1, norm)
norm(U)
norm(U, type="2")
norm(U[1.]
)
norm(U[1,])
?norm
apply(U, 1, norm, type=2)
apply(U, 1, lambda(x){norm(as.matrix(x), type=2)})
apply(U, 1, lambda(x){norm(as.matrix(x), type=2)})
apply(U, 1, lambda(x){norm(as.matrix(x), type=2)})
apply(U, 1, function(x){norm(as.matrix(x), type=2)})
apply(U, 1, function(x){norm(as.matrix(x), type="2")})
U <- scale(U)
apply(U, 1, function(x){norm(as.matrix(x), type="2")})
lev <- diag(U %*% t(U))
lev
U <- t(scale(t(U)))
lev
lev <- diag(U %*% t(U))
lev
apply(U, 1, function(x){norm(as.matrix(x), type="2")})
U <- matrix(rnorm(600), nrow=6)
U <- clever::scale_med(U)
devtools::install_github("mandymejia/clever")
remove.packages("clever")
devtools::install_github("mandymejia/clever")
install.packages("glmgen")
install.packages("glmgen")
install_github("statsmaths/glmgen", subdir="R_pkg/glmgen")
devtools::install_github("statsmaths/glmgen", subdir="R_pkg/glmgen")
devtools::install_github("statsmaths/glmgen", subdir="R_pkg/glmgen", force=TRUE)
devtools::install_github("mandymejia/clever")
library(clever)
U <- scale_med(U)
U <- clever::scale_med(U)
scale_med <- function(mat){
TOL <- 1e-8
mat <- t(mat)
#	Center.
mat <- mat - c(rowMedians(mat, na.rm=TRUE))
# Scale.
mad <- 1.4826 * rowMedians(abs(mat), na.rm=TRUE)
const_mask <- mad < TOL
if(any(const_mask)){
if(all(const_mask)){
stop("All voxels are zero-variance.\n")
} else {
warning(paste0("Warning: ", sum(const_mask),
" constant voxels (out of ", length(const_mask),
" ). These will be removed for estimation of the covariance.\n"))
}
}
mad <- mad[!const_mask]
mat <- mat[!const_mask,]
mat <- mat/c(mad)
# Revert transpose.
mat <- t(mat)
N_ <- ncol(mat)
out <- list(mat=mat, const_mask=const_mask)
return(out)
}
U <- scale_med(U)
library(robustbase)
U <- scale_med(U)
diag(U %*% t(U))
U <- scale_med(U)$mat
X <- scale_med(matrix(rnorm(600), nrow=8))
X <- svd(X)
X <- svd(X$mat)
U <- X$u[,1:5]
t(U) %*% U
diag(U %*% t(U))
diag(U %*% t(U)) %>% sum
sum(diag(U %*% t(U)))
apply(U, 1, function(x){norm(as.matrix(x), "2")})
?norm
apply(U, 1, function(x){norm(as.matrix(x), "f")})
apply(U, 2, function(x){norm(as.matrix(x), "f")})
apply(U, 1, function(x){norm(as.matrix(x), "f")})
apply(U, 1, function(x){norm(matrix(x), "f")})
apply(U, 1, function(x){norm(matrix(x, nrow=1), "f")})
apply(U, 1, function(x){norm(matrix(x, ncol=1), "f")})
apply(U, 1, function(x){norm(matrix(x, ncol=1), "2")})
apply(U, 1, function(x){norm(matrix(x, ncol=1), "1")})
apply(U, 1, function(x){norm(matrix(x, ncol=1), "I")})
apply(U, 1, function(x){norm(matrix(x, ncol=1), "M")})
U
apply(U, 1, function(x){dot(x)})
?length
apply(U, 1, function(x){sum(x*x)})
X <- scale_med(matrix(rnorm(600000), nrow=800))
X <- svd(X$mat)
U <- X$u[,1:500]
dim(U)
U <- scale_med(U)
U <- X$u[,1:500]
dim(U)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
U <- matrix(rnorm(1000000), nrow=50000)
source('~/.active-rstudio-document', echo=TRUE)
U <- matrix(rnorm(100000), nrow=50000)
source('~/.active-rstudio-document', echo=TRUE)
rm(X)
gc()
U <- matrix(rnorm(100000), nrow=5000)
source('~/.active-rstudio-document', echo=TRUE)
roxygen2::roxygenize()
