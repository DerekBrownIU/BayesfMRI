result <- vector('list', n_sess)
names(result) <- session_names
v
sess_name <- session_names[v]
inds_v <- (1:n_vox) + (v-1)*n_vox #indices of beta vector corresponding to session v
res.exc <- excursions.inla(INLA_result, name=field_name, ind=inds_v, u=threshold, type='>', method='QC', alpha=alpha, F.limit=0.2)
dim(session$BOLD)
a <- vector('list', 3)
a[[1]] <- vector('list', 2)
names(a) <- 'b', 'c'
names(a) <- c('b', 'c')
tmp <- 'b'
a
a[[1]]$b <- 'hello!'
a[[1]]$b
a[[1]]$tmp
a[[1]]$`tmp``
a[[1]]$`tmp`
field_name = NULL
model_obj=object
class(model_obj)
session_names <- model_obj$session_names
n_sess <- length(session_names)
n_vox <- mesh$n
if(is.null(field_name)) field_name <- model_obj$beta_names
field_name
if(!any(field_name %in% model_obj$beta_names)) stop("Please specify only field names that corresponds to one of the latent fields (i.e. 'bbeta1').")
if(alpha > 1 | alpha < 0) stop('alpha value must be between 0 and 1, and it is not')
if(length(model_obj$INLA_result$summary.random[[1]]$mean) != n_vox*n_sess) stop('Length of estimate vectors must equal number of sessions X number of voxels')
result <- vector('list', n_sess)
names(result) <- session_names
v=1
sess_name <- session_names[v]
inds_v <- (1:n_vox) + (v-1)*n_vox #indices of beta vector corresponding to session v
#loop over latent fields
result[[v]] <- vector('list', length(field_name))
names(result[[v]]) <- field_name
f=field_name[1]
res.exc <- excursions.inla(model_obj$INLA_result, name=f, ind=inds_v, u=threshold, type='>', method='QC', alpha=alpha, F.limit=0.2)
act_v <- res.exc$E[inds_v]
act_v[is.na(act_v)] <- 0
result[[v]][[which(field_name==f)]] <- list(active=act_v, excursions_result=res.exc)
result
class(res.exc)
model_obj$mesh$n
n_vox
dim(model_obj$beta_estimates)
dim(model_obj$beta_estimates$single_session)
res.exc$E[inds_v]
library(BayesfMRI)
library(roxygen2)
library(roxygen2md)
roxygenize()
roxygenize()
roxygenize()
library(BayesfMRI)
library(BayesfMRI)
roxygenize()
library(BayesfMRI)
library(BayesfMRI)
roxygenize()
library(BayesfMRI)
roxygenize()
library(BayesfMRI)
roxygenize()
sessionInfo()
inla.pardiso()
inla.pardiso()
inla.pardiso.check()
library(INLA)
inla.pardiso()
library(devtools)
install_github('mandymejia/BayesfMRI')
install.packages("available")
library(available)
available('BayesfMRI')
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(BayesfMRI)
## Read in the mask
mask <- as.matrix(read.table("example/Mask"))
mask2 <- as.matrix(read.table("example/Mask2"))
mask3D <- mask*mask2
## Create a mesh using inla.mesh.2d
xy.in <- which(mask3D==1, arr.ind=TRUE)[,2:1]
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
library(INLA)
## Read in the mask
mask <- as.matrix(read.table("example/Mask"))
mask2 <- as.matrix(read.table("example/Mask2"))
mask3D <- mask*mask2
## Create a mesh using inla.mesh.2d
xy.in <- which(mask3D==1, arr.ind=TRUE)[,2:1]
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
## Create a matrix to translate between original and mesh locations
Amat <- inla.spde.make.A(mesh, loc=xy.in)
## Plot mask and mesh
image(t(mask3D), xaxt='n', yaxt='n', col=c('white','black'))
plot(mesh, main='')
## Read in timeseries data
dat <- as.matrix(read.csv('example/FWHM20_NoisyData_1.csv', header=FALSE))
## Construct design matrix
z1 <- as.matrix(read.table('example/Z1.txt'))
z2 <- as.matrix(read.table('example/Z2.txt'))
Z <- cbind(z1, z2)
## Plot task regressors over time
plot(z1, type='l', ylab='', main='HRF Task Regressors')
lines(z2, col='red')
## Build session data
session <- list(BOLD = dat, design = Z)
is.session(session)
data <- list(single_session = session)
result <- BayesGLM(data, mesh=mesh)
#check that all elements of the data list are valid sessions and have the same number of locations and tasks
session_names <- names(data)
n_sess <- length(session_names)
if(!is.list(data)) stop('I expect data to be a list, but it is not')
data_classes <- sapply(data, 'class')
if(! all.equal(unique(data_classes),'list')) stop('I expect data to be a list of lists (sessions), but it is not')
V <- ncol(data[[1]]$BOLD) #number of data locations
K <- ncol(data[[1]]$design) #number of tasks
spde <- inla.spde2.matern(mesh)
#collect data and design matrices
y_all <- c()
X_all_list <- NULL
for(s in 1:n_sess){
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
#scale data to represent % signal change (or just center if scale=FALSE)
BOLD_s <- scale_timeseries(t(BOLD_s), scale=scale)
design_s <- scale(data[[s]]$design, scale=FALSE) #center design matrix to eliminate baseline
#regress nuisance parameters from BOLD data and design matrix
if('nuisance' %in% names(data[[s]])){
design_s <- data[[s]]$design
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- data[[s]]$design
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
vertices = NULL
faces = NULL
scale=TRUE
return_INLA_result=TRUE
for(s in 1:n_sess){
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
#scale data to represent % signal change (or just center if scale=FALSE)
BOLD_s <- scale_timeseries(t(BOLD_s), scale=scale)
design_s <- scale(data[[s]]$design, scale=FALSE) #center design matrix to eliminate baseline
#regress nuisance parameters from BOLD data and design matrix
if('nuisance' %in% names(data[[s]])){
design_s <- data[[s]]$design
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- data[[s]]$design
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
beta_names <- names(betas)
repl_names <- names(repls)
n_beta <- length(names(betas))
hyper_initial <- c(-2,2)
hyper_initial <- rep(list(hyper_initial), n_beta)
hyper_vec <- paste0(', hyper=list(theta=list(initial=', hyper_initial, '))')
formula_vec <- paste0('f(',beta_names, ', model = spde, replicate = ', repl_names, hyper_vec, ')')
formula_vec <- c('y ~ -1', formula_vec)
formula_str <- paste(formula_vec, collapse=' + ')
formula <- as.formula(formula_str, env = globalenv())
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
INLA_result <- estimate_model(formula=formula, data=model_data, A=model_data$X, spde=spde, prec_initial=1)
spde
summary(spde)
formula
class(model_data)
names(model_data)
class(model_data$bbeta1)
class(replicates_list)
class(replicates_list$betas)
names(replicates_list$betas)
class(replicates_list$betas$bbeta1)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
## Read in timeseries data
dat2 <- as.matrix(read.csv('example/FWHM20_NoisyData_2.csv', header=FALSE))
library(BayesfMRI)
library(INLA)
library(reshape2)
library(dplyr)
library(dplyr)
library(ggplot2)
load('example/Mask.Rdata') #mask3D
## Create a mesh using inla.mesh.2d
xy.in <- which(mask3D==1, arr.ind=TRUE)[,2:1]
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
## Create a matrix to translate between original and mesh locations
Amat <- inla.spde.make.A(mesh, loc=xy.in)
dat <- as.matrix(read.csv('example/FWHM20_NoisyData_1.csv', header=FALSE))
## Construct design matrix
z1 <- as.matrix(read.table('example/Z1.txt'))
z2 <- as.matrix(read.table('example/Z2.txt'))
Z <- cbind(z1, z2)
## Plot task regressors over time
plot(z1, type='l', ylab='', main='HRF Task Regressors')
lines(z2, col='red')
## Build session data
session <- list(BOLD = dat, design = Z)
is.session(session)
## Read in timeseries data
dat2 <- as.matrix(read.csv('example/FWHM20_NoisyData_2.csv', header=FALSE))
## Build session data
session2 <- list(BOLD = dat2, design = Z)
is.session(session2)
data <- list(sess1 = session, sess2 = session2)
result <- BayesfMRI::BayesGLM(data, mesh=mesh)
install.packages('alr4')
library(alr4)
View(BGSgirls)
min(5, NULL)
x <- rnorm(10000)
install.packages('entropy')
entropy(x)
library(entropy)
entropy(x)
log(sqrt(2*pi*exp(1)))
install.packages('DescTools')
library(DescTools)
h <- hist(x)
h <- hist(x, breaks=100)
names(h)
entropy(h$counts)
h <- hist(x, breaks=1000)
entropy(h$counts)
h <- hist(x, breaks=50)
entropy(h$counts)
library(devtools)
install_github('mandymejia/BayesfMRI')
library(BayesfMRI)
library(roxygen2)
library(roxygen2md)
roxygenize()
library(BayesfMRI)
roxygenize()
roxygenize()
roxygenize()
roxygenize()
roxygenize()
library(BayesfMRI)
library(devtools)
install_github('mandymejia/BayesfMRI')
library(BayesfMRI)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(knitr)
# library(rgl)
knit_hooks$set(webgl = hook_webgl)
#library(devtools)
#install_github('mandymejia/BayesfMRI')
library(BayesfMRI)
library(INLA)
## Read in the mask
load('example/Mask.Rdata') #mask3D
## Create a mesh using inla.mesh.2d
xy.in <- which(mask3D==1, arr.ind=TRUE)[,2:1]
boundary <- inla.nonconvex.hull(xy.in, resolution = 100)
mesh <- inla.mesh.2d(loc = xy.in, boundary = boundary, max.edge = c(2, 4))
## Create a matrix to translate between original and mesh locations
Amat <- inla.spde.make.A(mesh, loc=xy.in)
## Plot mask and mesh
image(t(mask3D), xaxt='n', yaxt='n', col=c('white','black'))
plot(mesh, main='')
dat <- as.matrix(read.csv('example/FWHM20_NoisyData_1.csv', header=FALSE))
## Construct design matrix
z1 <- as.matrix(read.table('example/Z1.txt'))
z2 <- as.matrix(read.table('example/Z2.txt'))
Z <- cbind(z1, z2)
## Plot task regressors over time
plot(z1, type='l', ylab='', main='HRF Task Regressors')
lines(z2, col='red')
## Build session data
session <- list(BOLD = dat, design = Z)
is.session(session)
data <- list(single_session = session)
result <- BayesfMRI::BayesGLM(data, mesh=mesh)
result1 <- result
dat2 <- as.matrix(read.csv('example/FWHM20_NoisyData_2.csv', header=FALSE))
## Build session data
session2 <- list(BOLD = dat2, design = Z)
data2 <- list(single_session = session2)
result2 <- BayesfMRI::BayesGLM(data2, mesh=mesh, return_INLA_result=FALSE)
result.lst <- list(sub1 = result1, sub2 = result2)
Amat <- inla.spde.make.A(mesh, loc=xy.in)
thresholds <- c(0, 0.5)
result.grp <- BayesfMRI::BayesGLM_group(result.lst, A = Amat, thresholds = thresholds, alpha = 0.05)
list(a=1:3, b=3:4)
# Read beta estimates
beta.tot <- result.grp$beta_estimates
visualize_vec2img(
values = Amat %*% beta.tot,
field_names = c('beta1', 'beta2'),
pal = c('purple','blue','turquoise','yellow','orange','red','darkred'),
xy.inds = xy.in[,2:1],
zlim = c(-0.3, 1.3)
)
library(ggplot2)
visualize_vec2img <- function(values, field_names, xy.inds, pal=NULL, gradient2=FALSE, zlim=NULL){
#values is a matrix where each column is a vectorized, masked image
#names are the names of the fields corresponding to each column of values
#xy.in are the col- and row-indices in the original image corresponding to the rows of values
#pal is the color palette to use for the image
#zlim is a vector of the lower and upper limits for the intensity values
values_df <- data.frame(value = as.vector(values),
field = rep(field_names, each=length(values)/length(field_names)),
row = xy.inds[,1],
col = xy.inds[,2])
if(!is.null(zlim)){
print(paste0(sum(values_df$value > zlim[2]), ' pixels above upper z-limit')) #very few values
print(paste0(sum(values_df$value < zlim[1]), ' pixels above upper z-limit')) #very few values
values_df$value[values_df$value > zlim[2]] <- zlim[2]
values_df$value[values_df$value < zlim[1]] <- zlim[1]
}
p <- ggplot(values_df) +
geom_tile(aes(x = 41-row, y = col, color = value, fill = value)) +
facet_grid(. ~ field) + xlab('') + ylab('') +
theme_bw() + theme(panel.grid=element_blank())
if(!is.null(pal)){
p <- p + scale_color_gradientn("", colors=pal, na.value = "black", limits=zlim) +
scale_fill_gradientn("", colors=pal, na.value = "black", limits=zlim)
} else if (gradient2==TRUE) {
p <- p + scale_color_gradient2("", na.value = "black", limits=zlim) +
scale_fill_gradient2("", na.value = "black", limits=zlim)
} else {
p <- p + scale_color_gradient("", na.value = "black", limits=zlim) +
scale_fill_gradient("", na.value = "black", limits=zlim)
}
return(p)
}
# Visualize beta estimates
visualize_vec2img(
values = Amat %*% beta.tot,
field_names = c('beta1', 'beta2'),
pal = c('purple','blue','turquoise','yellow','orange','red','darkred'),
xy.inds = xy.in[,2:1],
zlim = c(-0.3, 1.3)
)
# Read activation regions
active <- result.grp$active
for(u in 1:length(thresholds)){
values = Amat %*% active[,,u]
values_all <- matrix(NA, nrow=length(mask3D), ncol=ncol(values))
values_all[as.vector(mask3D) == 1,] <- as.matrix(values)
visualize_vec2img(
values = values_all,
field_names = c('beta1', 'beta2'),
gradient2=TRUE,
xy.in = which(mask3D >= 0, arr.ind=TRUE)
)
}
library(alr4)
help("fuel2001")
scatterplotMatrix(fuel2001)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth()
library(ggplot2)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=Miles, y=MPC)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=MPC, y=FuelC)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth()
lm1 <- lm(FuelC ~ Miles, data=fuel2001)
fuel2001$pred_lm1 <- predict(lm1, fuel2001)
fuel2001$resid_lm1 <- fuel2001$FuelC - fuel2001$pred_lm1
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_smooth()
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth() + theme_few()
library(ggthemes)
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_vline(yintercept=0, col='red')
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_hline(yintercept=0, col='red')
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
plot(lm1)
par(mfrow=c(2,2))
plot(lm1, which = 1)
plot(lm1, which = 2)
plot(lm1, which = 3)
plot(lm1, which = 4)
plot(lm1)
plot(lm1)
par(mfrow=c(1,1))
plot(lm1)
hist(fuel2001$Miles)
hist(fuel2001$FuelC)
hist(fuel2001$Miles, breaks=30)
hist(fuel2001$FuelC, breaks=30)
hist(fuel2001$FuelC, breaks=30, fill='turquoise')
hist(fuel2001$Miles, breaks=30, col='turquoise')
hist(fuel2001$FuelC, breaks=30, col='turquoise')
hist(fuel2001$Miles, breaks=25, col='turquoise')
hist(fuel2001$FuelC, breaks=25, col='turquoise')
lm2 <- lm(log(FuelC) ~ Miles, data=fuel2001)
fuel2001$pred_lm1 <- predict(lm1, fuel2001)
fuel2001$resid_lm1 <- log(fuel2001$FuelC) - fuel2001$pred_lm1
lm2 <- lm(log(FuelC) ~ Miles, data=fuel2001)
fuel2001$pred_lm2 <- predict(lm2, fuel2001)
fuel2001$resid_lm2 <- log(fuel2001$FuelC) - fuel2001$pred_lm2
head(fuel2001)
ggplot(fuel2001, aes(x=pred_lm1, y=resid_lm1^2)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
ggplot(fuel2001, aes(x=pred_lm2, y=resid_lm2)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
ggplot(fuel2001, aes(x=pred_lm2, y=resid_lm2^2)) + geom_point() + geom_hline(yintercept=0, col='red') + theme_few()
library(alr4)
help(fuel2001)
scatterplotMatrix(fuel2001)
library(ggplot2)
library(ggthemes)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth() + theme_few()
hist(fuel2001$Miles, breaks=25, col='turquoise')
hist((fuel2001$FuelC), breaks=25, col='turquoise')
hist(fuel2001$FuelC, breaks=25, col='turquoise')
lm1 <- lm(FuelC ~ Miles, data=fuel2001)
fuel2001$pred_lm1 <- predict(lm1, fuel2001)
fuel2001$resid_lm1 <- fuel2001$FuelC - fuel2001$pred_lm1
par(mfrow=c(2,2))
plot(lm1, which = 1)
plot(lm1, which = 2)
plot(lm1, which = 3)
plot(lm1, which = 5)
ggplot(fuel2001, aes(x=Miles, y=FuelC)) + geom_point() + geom_smooth() + theme_few()
hist(fuel2001$FuelC, breaks=25, col='turquoise')
ggplot(fuel2001, aes(x=Miles, y=log(FuelC))) + geom_point() + geom_smooth() + theme_few()
lm2 <- lm(log(FuelC) ~ Miles, data=fuel2001)
fuel2001$pred_lm2 <- predict(lm2, fuel2001)
fuel2001$resid_lm2 <- log(fuel2001$FuelC) - fuel2001$pred_lm2
par(mfrow=c(2,2))
plot(lm2, which = 1)
plot(lm2, which = 2)
plot(lm2, which = 3)
plot(lm2, which = 5)
hist(fuel2001$Pop, breaks=30, col='turquoise')
fuel2001$large_state <- (fuel2001$Pop > 1.0e7)
table(fuel2001$large_state)
ggplot(fuel2001, aes(x=Miles, y=log(FuelC), group=large_state, color=large_state)) + geom_point() + geom_smooth() + theme_few()
lm3int <- lm(log(FuelC) ~ Miles*large_state, data=fuel2001)
lm3int <- lm(log(FuelC) ~ Miles + large_state + Miles:large_state, data=fuel2001)
lm3 <- lm(log(FuelC) ~ Miles + large_state, data=fuel2001)
Miles_pred <- seq(0, 3e5, 1)
large_state_pred <- c(TRUE, FALSE)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred)
newdata$fitted_lm3int <- predict(lm3int, newdata=newdata)
newdata$fitted_lm3 <- predict(lm3, newdata=newdata)
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line()
Miles_pred <- seq(0, 3e5, 1000)
large_state_pred <- c(TRUE, FALSE)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred)
newdata$fitted_lm3int <- predict(lm3int, newdata=newdata)
newdata$fitted_lm3 <- predict(lm3, newdata=newdata)
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line()
ggplot(fuel2001, aes(x=Miles, y=log(FuelC), group=large_state, color=large_state)) + geom_point() + geom_smooth() + theme_few() + theme(legend.position='bottom')
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm3, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
ggplot(newdata, aes(x=Miles, y=fitted_lm3int, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
hist(fuel2001$Income)
lm4 <- lm(log(FuelC) ~ Miles + large_state + Income, data=fuel2001)
Miles_pred <- seq(0, 3e5, 1000)
large_state_pred <- c(TRUE, FALSE)
Income_pred <- seq(20000,45000,100)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred, Income=Income_pred)
newdata$fitted_lm4 <- predict(lm4, newdata=newdata)
newdata_Incomefixed <- filter(newdata, Income==30000)
newdata <- expand.grid(Miles=Miles_pred, large_state=large_state_pred, Income=Income_pred)
newdata$fitted_lm4 <- predict(lm4, newdata=newdata)
ggplot(newdata, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line()
ggplot(newdata, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
newdata_Incomefixed <- filter(newdata, Income==30000)
ggplot(newdata_Incomefixed, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
library(dplyr)
newdata_Incomefixed <- dplyr::filter(newdata, Income==30000)
ggplot(newdata_Incomefixed, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
p1 <- ggplot(newdata, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
p2 <- ggplot(newdata_Incomefixed, aes(x=Miles, y=fitted_lm4, group=large_state, color=large_state)) + geom_line() + theme_few() + theme(legend.position='bottom')
library(gridExtra)
grid.arrange(p1, p2)
grid.arrange(p1, p2, nrow=1)
