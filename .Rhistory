design_s <- data[[s]]$design
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- data[[s]]$design
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
library(BayesfMRI)
for(s in 1:n_sess){
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
#scale data to represent % signal change (or just center if scale=FALSE)
BOLD_s <- scale_timeseries(t(BOLD_s), scale=scale)
design_s <- scale(data[[s]]$design, scale=FALSE) #center design matrix to eliminate baseline
#regress nuisance parameters from BOLD data and design matrix
if('nuisance' %in% names(data[[s]])){
design_s <- data[[s]]$design
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- data[[s]]$design
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$A)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
library(BayesfMRI)
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
#'
#' @examples \dontrun{}
organize_replicates <- function(n_sess, n_task, mesh){
if(!(class(mesh) %in% c('inla.mesh','BayesfMRI.spde'))) stop('mesh must be of class inla.mesh  (for surface data, see help(make_mesh)) or BayesfMRI.spde (for subcortical data, see help(create_spde_vol3D))')
spatial <- unlist(mesh$idx)
nvox <- length(spatial)
grps <- ((1:(n_sess*n_task) + (n_task-1)) %% n_task) + 1 # 1, 2, .. n_task, 1, 2, .. n_task, ...
repls <- vector('list', n_task)
betas <- vector('list', n_task)
for(i in 1:n_task){
inds_i <- (grps == i)
#set up replicates vectors
sess_NA_i <- rep(NA, n_sess*n_task)
sess_NA_i[inds_i] <- 1:n_sess
repls[[i]] <- rep(sess_NA_i, each=nvox)
names(repls)[i] <- paste0('repl',i)
#set up ith beta vector with replicates for sessions
NAs <- rep(NA, nvox)
preNAs <- rep(NAs, times=(i-1))
postNAs <- rep(NAs, times=(n_task-i))
betas[[i]] <- rep(c(preNAs, spatial, postNAs), n_sess)
names(betas)[i] <- paste0('bbeta',i)
}
result <- list(betas=betas, repls=repls)
return(result)
}
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
beta_names <- names(betas)
repl_names <- names(repls)
n_beta <- length(names(betas))
hyper_initial <- c(-2,2)
hyper_initial <- rep(list(hyper_initial), n_beta)
hyper_vec <- paste0(', hyper=list(theta=list(initial=', hyper_initial, '))')
formula_vec <- paste0('f(',beta_names, ', model = spde, replicate = ', repl_names, hyper_vec, ')')
formula_vec <- c('y ~ -1', formula_vec)
formula_str <- paste(formula_vec, collapse=' + ')
formula <- as.formula(formula_str, env = globalenv())
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
INLA_result <- estimate_model(formula=formula, data=model_data, A=model_data$X, spde=spde, prec_initial=1, num.threads=num.threads)
formula
names(model_data)
head(model_data$y)
head(model_data$X)
head(model_data$bbeta1)
length(model_data$bbeta1)
V
dim(Amat)
model_data$bbeta1
View(cbind(model_data$bbeta1, model_data$bbeta2))
dim(Amat)
1198*2
n_sess
K
dim(replicates_list$repls)
length(replicates_list$repls)
plot(replicates_list$repls[[1]], replicates_list$repls[[2]])
View(cbind(replicates_list$repls[[1]], replicates_list$repls[[2]]))
n_task
n_task=K
n_sess
spatial <- unlist(mesh$idx)
length(spatial)
length(spatial)*2
names(mesh)
mesh$n
mesh$meta
mesh$idx
mesh$idx$loc
length(mesh$idx$loc)
mesh$idx
#'
#' @examples \dontrun{}
organize_replicates <- function(n_sess, n_task, mesh){
if(!(class(mesh) %in% c('inla.mesh','BayesfMRI.spde'))) stop('mesh must be of class inla.mesh  (for surface data, see help(make_mesh)) or BayesfMRI.spde (for subcortical data, see help(create_spde_vol3D))')
spatial <- mesh$idx$loc
nvox <- length(spatial)
grps <- ((1:(n_sess*n_task) + (n_task-1)) %% n_task) + 1 # 1, 2, .. n_task, 1, 2, .. n_task, ...
repls <- vector('list', n_task)
betas <- vector('list', n_task)
for(i in 1:n_task){
inds_i <- (grps == i)
#set up replicates vectors
sess_NA_i <- rep(NA, n_sess*n_task)
sess_NA_i[inds_i] <- 1:n_sess
repls[[i]] <- rep(sess_NA_i, each=nvox)
names(repls)[i] <- paste0('repl',i)
#set up ith beta vector with replicates for sessions
NAs <- rep(NA, nvox)
preNAs <- rep(NAs, times=(i-1))
postNAs <- rep(NAs, times=(n_task-i))
betas[[i]] <- rep(c(preNAs, spatial, postNAs), n_sess)
names(betas)[i] <- paste0('bbeta',i)
}
result <- list(betas=betas, repls=repls)
return(result)
}
#construct betas and repls objects
replicates_list <- organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
beta_names <- names(betas)
repl_names <- names(repls)
n_beta <- length(names(betas))
hyper_initial <- c(-2,2)
hyper_initial <- rep(list(hyper_initial), n_beta)
hyper_vec <- paste0(', hyper=list(theta=list(initial=', hyper_initial, '))')
formula_vec <- paste0('f(',beta_names, ', model = spde, replicate = ', repl_names, hyper_vec, ')')
formula_vec <- c('y ~ -1', formula_vec)
formula_str <- paste(formula_vec, collapse=' + ')
formula <- as.formula(formula_str, env = globalenv())
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
#estimate model using INLA
INLA_result <- estimate_model(formula=formula, data=model_data, A=model_data$X, spde=spde, prec_initial=1, num.threads=num.threads)
library(roxygen2)
library(roxygen2md)
roxygenize()
roxygenize()
install_github('ciftiTools')
library(devtools)
install_github('ciftiTools')
install_github('mandymejia/ciftiTools')
roxygenize()
library(INLA)
library(roxygen2)
library(roxygen2md)
roxygenize()
library(BayesfMRI)
library(ciftiTools)
library(INLA)
inla.setOption(pardiso.license = "~/pardiso.lic")
library(gifti)
library(matrixStats)
library(excursions)
wb_cmd <- '/Applications/workbench/bin_macosx64/wb_command'
#try to replicate original Bayesian GLM results
setwd('~/Box Sync/TEACHING/S681 SP2020/DataAnalysis/BayesGLM_test/')
fname_cifti <- '100307.6K.dtseries.nii'
#fname_gifti_left <- 'Sphere.6k.L.surf.gii'
#fname_gifti_right <- 'Sphere.6k.R.surf.gii'
fname_gifti_left <- '100307.L.midthickness.6k_fs_LR.surf.gii'
fname_gifti_right <- '100307.R.midthickness.6k_fs_LR.surf.gii'
resample = NULL
fname_Z <- 'task_100307_RL.csv'
Z <- read.csv(fname_Z, header=TRUE)
Z <- Z[,c('cue','rf','rh','t')] #exclude left motor tasks for left
Z <- as.matrix(Z)
Z <- Z/max(Z)
brainstructures = 'left'
design = Z
resample=NULL
fname_gifti2_left=NULL
fname_gifti2_right=NULL
onsets=NULL
nuisance=NULL
GLM_method='both'
session_names=NULL
do_Bayesian <- (GLM_method %in% c('both','Bayesian'))
do_classical <- (GLM_method %in% c('both','classical'))
# Check that arguments are compatible
do_left <- ('left' %in% brainstructures)
do_right <- ('right' %in% brainstructures)
do_sub <- ('subcortical' %in% brainstructures)
if(do_left & is.null(fname_gifti_left)) stop('fname_gifti_left must be provided if brainstructures includes "left"')
if(do_right & is.null(fname_gifti_right)) stop('fname_gifti_left must be provided if brainstructures includes "left"')
if((is.null(design) + is.null(onsets)) != 1) stop('design OR onsets must be provided, but not both')
if(do_sub){
if(length(unique(vol_regions)) != length(vol_regions)) stop('vol_regions must contain no repeated values.')
if(min(is.element(vol_regions, 3:21))==0) stop('vol_regions must include only integer values between 3 and 21.')
}
# Name sessions and check compatibility of multi-session arguments
n_sess <- length(fname_cifti)
if(n_sess==1){
if(is.null(session_names)) session_names <- 'single_session'
if(!is.null(design)) design <- list(design)
#if(!is.null(onsets)) onsets <- list(onsets)
if(!is.null(nuisance)) nuisance <- list(nuisance)
} else {
if(is.null(session_names)) session_names <- paste0('session', 1:n_sess)
if(!is.null(design)){ if(length(design) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), design must be a list of length equal to the number of sessions (or NULL, if onsets provided).') }
#if(!is.null(onsets)){ if(length(onsets) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), onsets must be a list of length equal to the number of sessions (or NULL, if design provided).') }
if(!is.null(nuisance)){ if(length(nuisance) != n_sess) stop('If multiple sessions provided (because fname_cifti is a vector), nuisance must be a list of length equal to the number of sessions (or NULL).') }
}
if(length(session_names) != n_sess) stop('If session_names is provided, it must be of the same length as fname_cifti')
cat('\n SETTING UP DATA \n')
### For each session, separate the CIFTI data into left/right/sub and read in files
if(do_left) cifti_left <- vector('list', n_sess)
if(do_right) cifti_right <- vector('list', n_sess)
if(do_sub) nifti_data <- nifti_labels <- vector('list', n_sess)
for(ss in 1:n_sess){
cifti_ss <- cifti_read_separate(fname_cifti[ss], brainstructures=brainstructures, wb_cmd=wb_cmd)
if(do_left) cifti_left[[ss]] <- cifti_ss$CORTEX_LEFT
if(do_right) cifti_right[[ss]] <- cifti_ss$CORTEX_RIGHT
if(do_sub) nifti_data[[ss]] <- cifti_ss$VOL
if(do_sub & ss==1) nifti_labels[[ss]] <- cifti_ss$LABELS
}
#check that labels are the same across all sessions
if(do_sub) {
if(n_sess > 1) {
tmp <- sapply(nifti_labels, function(x) {all.equal(x,nifti_labels[[1]])})
if(min(tmp)==0) stop('Subcortical labels must match across all sessions in cifti data. Check compatibility of cifti files.')
}
nifti_labels <- nifti_labels[[1]]
}
cat('\n RUNNING MODELS \n')
classicalGLM_left <- classicalGLM_right <- classicalGLM_vol <- NULL
BayesGLM_left <- BayesGLM_right <- BayesGLM_vol <- NULL
cat('\n ... LEFT CORTEX \n')
#set up mesh
surf_left <- readGIfTI(fname_gifti_left)$data
verts_left <- surf_left$pointset
faces_left <- surf_left$triangle
if(min(faces_left)==0) faces_left <- faces_left + 1
#set up session list
session_data <- vector('list', n_sess)
names(session_data) <- session_names
for(ss in 1:n_sess){
sess <- list(BOLD = t(cifti_left[[ss]]), design=design[[ss]])
if(!is.null(nuisance)) sess$nuisance <- nuisance[[ss]]
session_data[[ss]] <- sess
}
data=session_data
vertices = verts_left
faces = faces_left
scale=TRUE
num.threads=4
outfile = NULL
return_INLA_result=FALSE
mesh = NULL
mask = NULL
# Check to see that the INLA package is installed
if (!requireNamespace("INLA", quietly = TRUE))
stop("This function requires the INLA package (see www.r-inla.org/download)")
# Check to see if PARDISO is installed
if(!exists("inla.pardiso.check", mode = "function")){
warning("Please update to the latest version of INLA for full functionality and PARDISO compatibility (see www.r-inla.org/download)")
}else{
if(inla.pardiso.check() == "FAILURE: PARDISO IS NOT INSTALLED OR NOT WORKING"){
warning("Consider enabling PARDISO for faster computation (see inla.pardiso())")}
else {
inla.setOption(smtp='pardiso')
}
#inla.pardiso()
}
#check that only mesh OR vertices+faces supplied
has_mesh <- !is.null(mesh)
has_verts_faces <- !is.null(vertices) & !is.null(faces)
has_howmany <- has_mesh + has_verts_faces
if(has_howmany != 1) stop('Must supply EITHER mesh OR vertices and faces.')
#check that all elements of the data list are valid sessions and have the same number of locations and tasks
session_names <- names(data)
n_sess <- length(session_names)
if(!is.list(data)) stop('I expect data to be a list, but it is not')
data_classes <- sapply(data, 'class')
if(! all.equal(unique(data_classes),'list')) stop('I expect data to be a list of lists (sessions), but it is not')
V <- ncol(data[[1]]$BOLD) #number of data locations
K <- ncol(data[[1]]$design) #number of tasks
for(s in 1:n_sess){
if(! is.session(data[[s]])) stop('I expect each element of data to be a session object, but at least one is not (see `is.session`).')
if(ncol(data[[s]]$BOLD) != V) stop('All sessions must have the same number of data locations, but they do not.')
if(ncol(data[[s]]$design) != K) stop('All sessions must have the same number of tasks (columns of the design matrix), but they do not.')
}
if(is.null(outfile)){
message('No value supplied for outfile, which is required for post-hoc group modeling.')
}
if(is.null(mesh)) mesh <- make_mesh(vertices, faces)
#ID any zero-variance voxels and remove from analysis
zero_var <- sapply(data, function(x){
x$BOLD[is.na(x$BOLD)] <- 0 #to detect medial wall locations coded as NA
x$BOLD[is.nan(x$BOLD)] <- 0 #to detect medial wall locations coded as NaN
vars <- colVars(x$BOLD)
return(vars < 1e-6)
})
zero_var <- (rowSums(zero_var) > 0) #check whether any vertices have zero variance in any session
#1. Apply mask to mesh, data and zero_var
#2. If sum(zero_var) > 0, remove zero_var locations from data and create Amat
#   Else, let Amat = identity matrix
if(sum(zero_var) > 0){
if(!is.null(mask)) mask[zero_var==TRUE] <- 0
if(is.null(mask)) mask <- !zero_var
}
if(!is.null(mask)) {
mask <- as.logical(mask)
mesh <- submesh.mesh(mask, mesh)
mesh$idx$loc <- mesh$idx$loc[!is.na(mesh$idx$loc)]
for(s in 1:n_sess){
data[[s]]$BOLD <- data[[s]]$BOLD[,mask]
}
V <- sum(mask)
#zero_var <- zero_var[mask]
}
V
spde <- inla.spde2.matern(mesh)
#collect data and design matrices
y_all <- c()
X_all_list <- NULL
for(s in 1:n_sess){
#extract and mask BOLD data for current session
BOLD_s <- data[[s]]$BOLD
#scale data to represent % signal change (or just center if scale=FALSE)
BOLD_s <- scale_timeseries(t(BOLD_s), scale=scale)
design_s <- scale(data[[s]]$design, scale=FALSE) #center design matrix to eliminate baseline
#regress nuisance parameters from BOLD data and design matrix
if('nuisance' %in% names(data[[s]])){
nuisance_s <- data[[s]]$nuisance
y_reg <- nuisance_regress(BOLD_s, nuisance_s)
X_reg <- nuisance_regress(design_s, nuisance_s)
} else {
y_reg <- BOLD_s
X_reg <- design_s
}
#set up data and design matrix
data_org <- organize_data(y_reg, X_reg)
y_vec <- data_org$y
X_list <- list(data_org$X)
names(X_list) <- session_names[s]
y_all <- c(y_all, y_vec)
X_all_list <- c(X_all_list, X_list)
}
#construct betas and repls objects
replicates_list <- BayesfMRI:::organize_replicates(n_sess=n_sess, n_task=K, mesh=mesh)
betas <- replicates_list$betas
repls <- replicates_list$repls
beta_names <- names(betas)
repl_names <- names(repls)
n_beta <- length(names(betas))
hyper_initial <- c(-2,2)
hyper_initial <- rep(list(hyper_initial), n_beta)
hyper_vec <- paste0(', hyper=list(theta=list(initial=', hyper_initial, '))')
formula_vec <- paste0('f(',beta_names, ', model = spde, replicate = ', repl_names, hyper_vec, ')')
formula_vec <- c('y ~ -1', formula_vec)
formula_str <- paste(formula_vec, collapse=' + ')
formula <- as.formula(formula_str, env = globalenv())
model_data <- make_data_list(y=y_all, X=X_all_list, betas=betas, repls=repls)
length(model_data$X[[1]])
length(model_data$X)
class(X_list)
class(X_all_list)
class(model_data$X)
system.time(INLA_result <- estimate_model(formula=formula, data=model_data, A=model_data$X, spde, prec_initial=1, num.threads=num.threads, verbose=TRUE))
#extract useful stuff from INLA model result
beta_estimates <- extract_estimates(object=INLA_result, session_names=session_names, mask=mask) #posterior means of latent task field
theta_posteriors <- get_posterior_densities(object=INLA_result, spde, beta_names) #hyperparameter posterior densities
#extract stuff needed for group analysis
mu.theta <- INLA_result$misc$theta.mode
Q.theta <- solve(INLA_result$misc$cov.intern)
result <- list(INLA_result = NULL,
mesh = mesh,
mask = mask,
session_names = session_names,
beta_names = beta_names,
beta_estimates = beta_estimates,
theta_posteriors = theta_posteriors,
mu.theta = mu.theta, #for joint group model
Q.theta = Q.theta, #for joint group model
y = y_all, #for joint group model
X = X_all_list, #for joint group model
call = match.call())
class(result) <- "BayesGLM"
BayesGLM_left=result
#LEFT CORTEX
if(do_left){
if(!is.null(fname_gifti2_left)){
gifti_left <- readGIfTI(fname_gifti2_left)$data
verts_left <- gifti_left$pointset
faces_left <- gifti_left$triangle + 1
surf_left <- list(vertices = verts_left, faces = faces_left)
} else {
surf_left <- list(vertices = verts_left, faces = faces_left)
}
} else {
surf_left <- NULL
}
classicalGLM_cifti <- BayesGLM_cifti <- vector('list', n_sess)
names(classicalGLM_cifti) <- names(BayesGLM_cifti) <- session_names
if(do_Bayesian){
BayesGLM_cifti[[ss]] <- cifti_make(cortex_left = BayesGLM_left$beta_estimates[[ss]],
cortex_right = BayesGLM_right$beta_estimates[[ss]],
surf_left = surf_left,
surf_right = surf_right,
surf_names = 'surface',
#subcortical = BayesGLM_vol$single_session,
#mask = mask,
#labels = nifti_labels
)
}
result <- list(betas = list(Bayesian=BayesGLM_cifti,
classical=classicalGLM_cifti),
GLM = list(Bayesian = list(cortex_left = BayesGLM_left,
cortex_right = BayesGLM_right,
subcortical = BayesGLM_vol),
classical = list(cortex_left = classicalGLM_left,
cortex_right = classicalGLM_right,
subcortical = classicalGLM_vol)))
model_test <- result
names(result)
do_Bayesian
cifti = cifti_make(cortex_left = BayesGLM_left$beta_estimates[[ss]],
cortex_right = BayesGLM_right$beta_estimates[[ss]],
surf_left = surf_left,
surf_right = surf_right,
surf_names = 'surface',
#subcortical = BayesGLM_vol$single_session,
#mask = mask,
#labels = nifti_labels
)
surf_right <- NULL
BayesGLM_cifti[[ss]] <- cifti_make(cortex_left = BayesGLM_left$beta_estimates[[ss]],
cortex_right = BayesGLM_right$beta_estimates[[ss]],
surf_left = surf_left,
surf_right = surf_right,
surf_names = 'surface',
#subcortical = BayesGLM_vol$single_session,
#mask = mask,
#labels = nifti_labels
)
result <- list(betas = list(Bayesian=BayesGLM_cifti,
classical=classicalGLM_cifti),
GLM = list(Bayesian = list(cortex_left = BayesGLM_left,
cortex_right = BayesGLM_right,
subcortical = BayesGLM_vol),
classical = list(cortex_left = classicalGLM_left,
cortex_right = classicalGLM_right,
subcortical = classicalGLM_vol)))
model_test = result
summary(model_test$betas$Bayesian$single_session$CORTEX_LEFT)
cifti_view(cifti = model_test$betas$Bayesian$single_session,
brainstructure = 'left',
z_lim = c(-1,1), w=2)
cifti_view(cifti = model_test$betas$Bayesian$single_session,
brainstructure = 'left',
z_lim = c(-1,1), w=3)
cifti_view(cifti = model_test$betas$Bayesian$single_session,
brainstructure = 'left',
z_lim = c(-2,2), w=3)
cifti_view(cifti = model_test$betas$Bayesian$single_session,
brainstructure = 'left',
z_lim = c(-2,2), w=4)
getwd()
setwd('~/Box Sync/SOFTWARE/BayesfMRI/')
roxygenize()
library(roxygen2)
library(roxygen2md)
roxygenize()
roxygenize()
tvals <- matrix(rnorm(4), ncol=2)
pnorm(tvals)
tvals
library(Matrix)
help(rankMatrix)
library(SQUAREM)
cite(squarem())
cite(squarem
)
help(cite)
help("citation")
citation(package='SQUAREM')
help("squarem")
help("SQUAREM")
packageVersion("SQUAREM")
library(INLA)
help(inla.mesh.2d)
help(inla.nonconvex.hull)
