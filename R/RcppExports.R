# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Find the log of the determinant of Q_tilde
#'
#' @param kappa2 a scalar
#' @param in_list a list with elements Cmat, Gmat, and GtCinvG
#' @param n_sess the integer number of sessions
#' @export
logDetQt <- function(kappa2, in_list, n_sess) {
    .Call(`_BayesfMRI_logDetQt`, kappa2, in_list, n_sess)
}

#' Second derivative of the first term in the objective function for kappa2
#'
#' @param spde a list with elements Cmat, Gmat, and GtCinvG
#' @param grid_size the number of grid points at which to numerically evaluate
#'   the second derivative
#' @param Ns the integer number of samples for the Hutchinson approximation
#' @param grid_limit the largest number in the grid
#' @export
d2f1_kappa <- function(spde, grid_size = 50L, Ns = 200L, grid_limit = 20.0) {
    .Call(`_BayesfMRI_d2f1_kappa`, spde, grid_size, Ns, grid_limit)
}

#' Find the initial values of kappa2 and phi
#'
#' @param theta a vector of length two containing the range and scale parameters
#'   kappa2 and phi, in that order
#' @param spde a list containing the sparse matrix elements Cmat, Gmat, and GtCinvG
#' @param w the beta_hat estimates for a single task
#' @param n_sess the number of sessions
#' @param tol the stopping rule tolerance
#' @param verbose (logical) Should intermediate output be displayed?
#' @export
initialKP <- function(theta, spde, w, n_sess, tol, verbose) {
    .Call(`_BayesfMRI_initialKP`, theta, spde, w, n_sess, tol, verbose)
}

#' Perform the EM algorithm of the Bayesian GLM fitting
#'
#' @param theta the vector of initial values for theta
#' @param spde a list containing the sparse matrix elements Cmat, Gmat, and GtCinvG
#' @param y the vector of response values
#' @param X the sparse matrix of the data values
#' @param QK a sparse matrix of the prior precision found using the initial values of the hyperparameters
#' @param Psi a sparse matrix representation of the basis function mapping the data locations to the mesh vertices
#' @param A a precomputed matrix crossprod(X%*%Psi)
#' @param Ns the number of columns for the random matrix used in the Hutchinson estimator
#' @param tol a value for the tolerance used for a stopping rule (compared to
#'   the squared norm of the differences between \code{theta(s)} and \code{theta(s-1)})
#' @param CG (logical) Should conjugate gradient methods be used?
#' @param verbose (logical) Should intermediate output be displayed?
#' @export
findTheta <- function(theta, spde, y, X, QK, Psi, A, Ns, tol, CG = FALSE, verbose = FALSE) {
    .Call(`_BayesfMRI_findTheta`, theta, spde, y, X, QK, Psi, A, Ns, tol, CG, verbose)
}

#' Get the prewhitening matrix for a single data location
#'
#' @param AR_coeffs a length-p vector where p is the AR order
#' @param nTime (integer) the length of the time series that is being prewhitened
#' @param avg_var a scalar value of the residual variances of the AR model
#' @export
getSqrtInvCpp <- function(AR_coeffs, nTime, avg_var) {
    .Call(`_BayesfMRI_getSqrtInvCpp`, AR_coeffs, nTime, avg_var)
}

